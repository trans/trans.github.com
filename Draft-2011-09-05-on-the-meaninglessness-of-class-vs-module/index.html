<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>7R4N5.C0D3 - Fear Not the Wereclass</title>

    <link rel="stylesheet" href="/smeagol/main.css" type="text/css"/> 
    <link rel="stylesheet" href="/smeagol/pygment.css" type="text/css"/>

    <link rel="stylesheet" href="/assets/styles/custom.css?reload=true" type="text/css"/>
    <link rel="stylesheet" href="/assets/styles/social.css?reload=true" type="text/css"/>  

    <!--[if lt IE 9]>
    <script src="/smeagol/html5.js"></script>
    <![endif]-->

    <script type="text/javascript" src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

    <script type="text/javascript" src="/assets/scripts/jquery.easing.js"></script>
    <script type="text/javascript" src="/assets/scripts/jquery.social.share.1.2.min.js"></script>

    <script src="/assets/scripts/main.js"></script>

    <script>
      $(document).ready(function(){
        $('#social-share').dcSocialShare({
          twitterId: 'transgigamic',
          tabText: '<img src="/assets/images/tab_share.png" alt="Share" />',
          buttons: 'twitter,facebook,plusone,stumbleupon,digg,linkedin,pinit'
        });
      });
    </script>

</head>

<body>
	
  <div id="container">
		<div id="header">
			<h1>7R4N5.C0D3</h1>
		</div>

    

		<div id="nav">
      <ul>
<li><a href="/">I BLOG</a></li>
<li><a href="/I-MAKE">I MAKE</a></li>
<li><a href="/I-USE">I USE</a></li>
<li><a href="/I-READ">I READ</a></li>
</ul>

		</div>

		<article>
    	<div id="content">
        <b class="path">&gt; Fear Not the Wereclass</b>
        <h1>Fear Not the Wereclass</h1>

<p>
  <strong>DRAFT</strong>
</p>

<p>In the spirit of the Halloween season, lets take a fun example, the Warewolf. Let us say we already have classes for Man and Wolf at our dispossal --some smart programmer already did the hard work for use and developed definitive representations:</p>

<div class="highlight"><pre>    <span class="k">class</span> <span class="nc">Man</span>
      <span class="k">def</span> <span class="nf">shoot_gun</span>
        <span class="nb">puts</span> <span class="s2">"Bang!"</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">"After it!"</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Wolf</span>
      <span class="k">def</span> <span class="nf">howl</span>
        <span class="nb">puts</span> <span class="s2">"Awoooooooo"</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">"Woosh!"</span>
      <span class="k">end</span>
    <span class="k">end</span>
</pre>
</div>


<p>Now what about a Werewolf? Half-man and half-wolf, what superclass do we use in its case? Most classes have clear superclass, but some, such as our werewolf, it is not so clear cut. Perhaps we decide that a werewolf in our universe is more like a wolf than a man, so:</p>

<div class="highlight"><pre>    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Wolf</span>
    <span class="k">end</span>
</pre>
</div>


<p>But we are still left to add Man's qualites to our Werewolf. Ruby gives us no easy way to do this given our original classes. So we are forced to refactor the former Man class into a module, like:</p>

<div class="highlight"><pre>    <span class="k">module</span> <span class="nn">ManLike</span>
      <span class="k">def</span> <span class="nf">shoot_gun</span>
        <span class="nb">puts</span> <span class="s2">"Bang!"</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">"After it!"</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Man</span>
      <span class="kp">include</span> <span class="no">ManLike</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Wolf</span>
      <span class="kp">include</span> <span class="no">ManLike</span>
    <span class="k">end</span>
</pre>
</div>


<p>Well there you go, a bit long winded perhaps, but it does the deed. But, hang on. It appears things are a bit worse off than we might have suspected. We thought by using Wolf as the superclass we were saying a warewolf is essentially a wolf, but with some man like qualities. Surely that is what it must mean for a Warewolf to be a subclass of a Wolf. Unfortunately we would be wrong. When we ask a warewolf to <code>give_chase</code>, we discover it is doing it in quite the mainly way, not the wolfly way.</p>

<div class="highlight"><pre>    <span class="n">werewolf</span> <span class="o">=</span> <span class="no">Werewolf</span><span class="o">.</span><span class="n">new</span>
    <span class="n">werewold</span><span class="o">.</span><span class="n">give_chase</span>  <span class="c1">#=&gt; "After it!"</span>
</pre>
</div>


<p>Oh dear, that's not good. The difference lies in the order of lookup. If two methods conflict, guess which one takes precedence? Would you be suprised to know that is not the superclass, but the rather the mixin?</p>

<p>Well, it doesn't make a great deal of sense, but clearly we have no choice, we must refactor again.</p>

<div class="highlight"><pre>    <span class="k">module</span> <span class="nn">WolfLike</span>
      <span class="k">def</span> <span class="nf">howl</span>
        <span class="nb">puts</span> <span class="s2">"Awoooooooo"</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">"Woosh!"</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Wolf</span>
      <span class="kp">include</span> <span class="no">WolfLike</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Man</span>
      <span class="kp">include</span> <span class="no">WolfLike</span>
    <span class="k">end</span>
</pre>
</div>


<p>Well, there we are. Not our ideal conception of things, clearly, but it <i>does what we need it to</i>. Of course, in the real world the original classes are not necessarily under our control, leading us to the only and unenviable option of re-implementing everything. What a waste.</p>

<p>The fact the Ruby inheritance system in conjunction with it's mixin system produces a wonky order to method look-up; the fact that we can't <em>reuse</em> a class as a module when we might have need to do so; and the fact that we are left then only to do things in unseemly manners and duplicating lots of code too, well, to put it's all a bit frightful. But really, it not just our coding that become strained and more difficult --after all we are programmers, we "work around". No. What really is a shame is that it severely limits the utility of Ruby's inheritance model and contributes in no small part as to why we see so little <em>semantic</em> subclassing in Ruby programs, as opposed to the simplistic base-class designs that we frequently see.</p>

<p>But it is arbitrary.</p>

<p>Consider this little Halloween trick:</p>

<div class="highlight"><pre>  <span class="k">class</span> <span class="nc">Module</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span>
      <span class="n">c</span><span class="o">.</span><span class="n">include</span> <span class="nb">self</span>
      <span class="n">c</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</pre>
</div>


<p>The distinction between a module and a class it Ruby is purely a superficial one that has been hard coded into the language for no utilitarian reason. It is there only as an artifact of the original conceptualization.</p>

<p>Removing the distinction of class vs module has nothing to do with multiple inheritance. Classes still only have a single superclass. Rather it is the principle of ... that is being violated. There is no need for a module to know it's a module or class it know it's a class. Both are merely OOP-type encapsulations. What matters is how they are used.</p>

<p>There is also a wonderful side benefit from this removal. Load order would no longer matter when two different scripts attempt to utilize the same namespace. </p>

<p>Now I can all but guarantee that at some point someone, who very likely hasn't read this entire post, is going to say "use delegation". Yes, yes. I am a big fan of delegation myself. But that is not what this article is about. It is about the utilization of Ruby's inheritance and mixin system. If delegation were always the answer then we might as flush the whole inheritance and mixin things down the drain and use delegation for it all. But that's a different debate. The question here is, if we are going to have inheritance and mixins, then what's best for making good use of them.</p>
      </div>
    </article>

    <div id="comments">
      <!-- Commment vis Disqus -->
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /**
         * var disqus_identifier; [Optional but recommended: Define a unique identifier (e.g. post id or slug) for this thread] 
         */
        (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = 'http://transcode.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=transcode">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

		<div id="footer">
      <div class="tiger">
      </div>
			<small>Last edited by <b>7rans</b> on December 05, 2011.</small>
			<small style="float:right;">
				This site is a <a href="https://github.com/blog/699-making-github-more-open-git-backed-wikis">GitHub Wiki</a>
				mirror powered by <a href="http://smeagolrb.info">Smeagol</a>.
			</small>
		</div>

  </div>

  <div id="social-share"></div>
</body>
</html>
