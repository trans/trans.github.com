<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRANSCODE &mdash; Trans Technology and Programming Blog</title>
    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/images/trans-logo.png"/>
    <link href="/feed.xml" rel="alternate" type="application/rss+xml" title="TRANSCODE" />
    <meta name="title" content="TRANSCODE">
    <link rel="canonical" href="http://trans.github.com/">
     
           
    <meta property="og:title" content="TRANSCODE"/>
    <meta property="og:url" content="http://trans.github.com/"/>
    
    
    <meta property="og:site_name" content="TRANSCODE">
</head>
<body>
    
<section class="site-nav">
    <header>
        <nav id="navigation">
            <a class="brand" href="/">
                <img src="/images/trans-logo.png" alt="Inc" height="120px">
            </a>
            <a href="/" class="home">Blog</a>
            <a href="http://github.com/trans">Github</a>
            <a href="/About/">About</a>
        </nav>
        <nav class="tagline">
            <span>Check out all of my open source work</span>
            <a href="http://github.com/trans" class="btn btn-outline">Learn More</a>
        </nav>
    </header>
</section>

<div class="blog-cover" style="background-image:url(/images/blog-cover.jpg);">
    
    <section>
        <div class="container">
            <h1>TRANSCODE</h1>
            <h3>Trans Technology and Programming Blog</h3>
        
            
            <a href="https://twitter.com/transgigamic" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter"></i></a>
            
            
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss"></i>
            </a>
        </div>
    </section>
</div>

<article class="container">

  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2014/06/17/My-Critique-of-Elixir/" rel="prefetch">My Critique Of Elixir</a></h2>
            <p><p>First, let me admonish myself for having limited knowledge of the subject. I am far from an Elixir expert. So I readily defer to those with more experience that can make a solid contrary argument against my conclusions. However, as I am unlikely to continue on in my adventures with Elixir, this is clearly the only time I have left to opine on the topic. So I will do so, and feel free to take my opinions with as much salt as you feel necessary.</p>

<p>There are many things to like about Elixir. Most notable of them is it&#39;s inheritance from Erlang and it&#39;s improved syntax inspired by Ruby. Its Erlang roots bring so many great features to the table: true functional programming, rock solid stability, distributed computing, and so on. Anything that is good about Erlang, is likewise good about Elixir. On top of this, Elixir brings a much more pleasurable syntax and a few higher-level conveniences which really set it apart from Erlang. (Otherwise there would be no point but to use Erlang directly). But then there are the caveats. </p>

<p>On the minor end, Elixir&#39;s code documentation is a bit odd. Documentation of modules is placed within the <code>defmodule</code> block, while documentation of functions are placed on the outside the <code>def</code> blocks. Why the difference? In addition there is no sigil at the beginning of documentation lines to clearly indicate a comment. If a documentation section were large enough, one could mistake examples for actual program code. Only by the magic of syntax highlighters are we saved from any such &quot;at a glance&quot; error. </p>

<p>Then there is the minor issue of the <code>def</code> prefix on the definition of everything. <code>defmodule</code>, <code>defstruct</code>, <code>deftype</code>, etc. One can understand the desire to avoid too many keywords, but surely <code>module</code>, <code>struct</code> and <code>type</code> would do much better, as they do in almost every other language, and can be avoided as keywords if need be by appropriate context.</p>

<p>A little more troubling is the awful block syntax. Despite all the inspiration form Ruby, Elixir did not adopt Ruby&#39;s elegant block syntax. Instead we get a strange twist of <code>fn</code> keyword, an arrow <code>-&gt;</code> and an <code>end</code> keyword, all within the argument parenthetical.</p>
<div class="highlight"><pre><code class="elixir language-elixir" data-lang="elixir">  <span class="no">Enum</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="k">fn</span> <span class="n">x</span> <span class="o">-&gt;</span>
    <span class="o">...</span>
  <span class="k">end</span><span class="p">)</span>
</code></pre></div>
<p>It feels a bit more like Javascript than Ruby. Ironically, this ugliness doesn&#39;t save us from a whole mess of seemingly extraneous <code>do</code> statements everywhere. Every <code>def*</code> and even every condition like <code>if</code> also requires a <code>do</code> to define the subsequent block.</p>
<div class="highlight"><pre><code class="elixir language-elixir" data-lang="elixir">  <span class="k">if</span> <span class="n">ok?</span><span class="p">()</span> <span class="k">do</span>
<span class="k">     </span><span class="o">...</span>
  <span class="k">end</span>
</code></pre></div>
<p>It might not seem like much, but when you write enough code and find yourself having to always fix missing do&#39;s first off, you can&#39;t help but feel as if your time could be spent on more useful endeavors.</p>

<p>On a higher level of critique, I think Elixir, like Erlang and their ML brethren, suffer from <em>Overtype Syndrome</em>, if you will allow me to coin a phrase. Because the language is both functional and so strongly typed, every method comes by way of a module. So instead of say, <code>list.each{...}</code> as in Ruby, one much specify where <code>each</code> is defined, <code>Enum.each(list, ...)</code>. And because one must repeat these module names over and over, there is a naturally common practice of extreme abbreviation. In some fashion it&#39;s nice that names are concise. Yet it can be a bit difficult encountering module names like <code>IEx</code> in passing. In addition, we end up with a whole slew of modules and types with which to contend. Of course this can be true of any strongly typed language, but it seems especially so for the ML branch of languages.</p>

<p>Finally, my last niggle is with functional programming in general. Honestly, it&#39;s pretty awesome. But just as honestly, it is difficult. The lack of procedural techniques puts a significant onus on the functional language to provide a large set of easy to understand and easy to utilize functions to pipe together to achieve the desired result. Partly it is due to lack of experience in thinking functionally, but it is clear enough that even for very component functional programmers it can be a real challenge to piece together the right functions to solve a complex problem. I believe this is because functional programming forces you to think about the whole more so than procedural programming. With a procedure, one can quickly break down a problem into parts. e.g. &quot;I have an array of strings, which I need to iterate over and extract each word, and for each word, make it lowercase, and then update a hash table to track the number of times the word occurs.&quot; Easy enough. Functionally the reads more like, &quot;I need to build a dict via a flat-map over a list of strings and the list of words in each while lowering the case of each word, with an updated key/value pair.&quot; Or something like that. It is simply harder to even to talk in functional terms.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2014-17-June" title="June 17, 2014">June 17, 2014</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2014/03/29/Next-Level-Please/" rel="prefetch">Next Level Please</a></h2>
            <p><p>What I want my computer to do the following:</p>

<ul>
<li>Authenticate id</li>
<li>Manage privacy</li>
<li>Tell time and keep a calendar

<ul>
<li>Set reminders and alarms</li>
</ul></li>
<li>Provide weather report(s)</li>
<li>Map w/ Global positioning</li>
<li>Messaging (Text and Email)</li>
<li>Translate other languages</li>
<li>Search and Surf Internet</li>
<li>File Manager (Advanced)</li>
<li>Play music (personal and internet stations)</li>
<li>Show pictures

<ul>
<li>Multiple i/o Dropbox, Google Drive, Local ?</li>
</ul></li>
</ul>

<p>Premium modules</p>

<ul>
<li>Edit Photos</li>
<li>Vector Drawing (has own tools interface)</li>
</ul>

<h2>Interface</h2>

<p>Everything should be voice driven. Voice commands are translated into a set of objectives. The user can see these objectives in simple command form and decide if it is acceptable. </p>

<h2>Implementation</h2>

<p>Each module shall be written to a shared interchange specification. 
Messages are sent via JSON (or JSONP) and results received.
Some results contain caching <em>functors</em> which perform the same function as the original call.
The cache allows light-weight functionality to be hosted cost-effectively, without bandwidth saturation.</p>

<p>So for example, say I want to provide a photo effect algorithm.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">---
input:
  - uri: *.jpg *.png
  - return-type:
output:
  - File .jpg .png
</code></pre></div></p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2014-29-March" title="March 29, 2014">March 29, 2014</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2014/01/20/HTML-Follies/" rel="prefetch">Html Follies</a></h2>
            <p><p>HTML Follies</p>

<p><strong>DRAFT</strong></p>

<p>Despite all its glories, HTML also has some serious follies. I&#39;ve never thought highly of the W3C in general. They seem to be on a never ending quest to build standards at a snails pace, yet end up with a result that is barely an improvement over previous solutions --if not actually worse. And unfortunately it is too often at an intolerable level of new complexity. For some reason K.I.S.S. seems to have been left off their principles sheet. For some clear examples, consider [XMLST] and [XML-fo]. I think [Web Components] are the latest ranking member.</p>

<p>So let&#39;s go through some of the glaring issues with HTML, what would be an appropriate solution and perhaps make some suggestion for how to mitigate the issue while still under the yolk of current standards.</p>

<h2>Headers Ought to be Titles</h2>

<p>Presently HTML authors must handle the titling of sections as follows:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&lt;section&gt;
  &lt;h2&gt;New Chapter&lt;/h2&gt;
  &lt;p&gt;...&lt;/p&gt;
&lt;/section&gt;
</code></pre></div>
<p>We assume here that the author was at least wise enough to put the header in the section and not above it. But why <code>h2</code> (which is a common choice)? Why not <code>h1</code> or <code>h3</code>? Well, there is no real reason. The document creator simply choose <code>h2</code> because it was in suitable font size as setup in the CSS. And therein lies a clear failure of design. The element is not being selected semantically. A proper design would be:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&lt;section&gt;
  &lt;title&gt;New Chapter&lt;/title&gt;
  &lt;p&gt;...&lt;/p&gt;
&lt;/section&gt;
</code></pre></div>
<p>Alas, HTML has no <code>title</code> element (outside of <code>head</code>). We could argue for a numberless <code>h</code> instead, but it amounts to essentially the same thing. Yet the term <code>title</code> is much more telling. Likewise <code>subtitle</code> is much more telling than any <code>h2</code> or <code>h3</code>.</p>

<p><strong>What to do now?</strong> Our best course of action is to always use <code>h1</code> for titles and use <code>h2</code> for subtitles. Headers <code>h3</code>-<code>h6</code> should rarely, if ever, be of any use.</p>

<h2>Padding Undermines Width</h2>

<p>Technically this is a CSS issue, but these days it&#39;s not reasonable to separate it from HTML. The two are intractably linked. </p>

<p>Padding should not add width. If the width of an element is specified and a padding is added, then the inner width should reduce accordingly.</p>

<p>Thankfully this has been addressed in the latest HTML version. <em>Hallelujah!</em> ...</p>

<h2>Open Semantics</h2>

<p>Lastly, the ultimate end point of the development of HTML is to separate the markup of structure from that of the meaning of the tags. This is in fact what the W3C was attempting with XML and XSLT. But that approach failed. It was too complicated. A new approach using CSS instead of XSLT could do better.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&lt;chapter&gt;
  &lt;p&gt;...&lt;/p&gt;
&lt;/chapter&gt;
</code></pre></div>
<p>Chapter isn&#39;t a recognized tag. But the CSS could be used to identify it.</p>

<p>chapter {
    tag: section
  }</p>

<p>Thus the CSS informs the document to treat <code>chapter</code> tags as if they were <code>section</code> tags.</p>

<p>Current the W3C&#39;s solution to this is Web Components. And while some of the Web Components specification is needed for more complex problems. It is still has a piss poor interface, and is a complete overkill for simple cases like the one above.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2014-20-January" title="January 20, 2014">January 20, 2014</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/09/17/Transpilers-to-Watch/" rel="prefetch">Transpilers To Watch</a></h2>
            <p><h1>Transpilers are the new Black (Coffee)</h1>

<p><a href="http://coffeescript.org">CoffeeScript</a> is fairly ubiquitous technology these days --a <em>transpiler</em> that converts it&#39;s own, much nicer language into Javascript, which can then be run via Node.js or on the Web. But it&#39;s not the only fish in this sea. Here are three similar projects that look very promising.</p>

<h2><a href="http://texodus.github.io/forml/">Forml</a></h2>

<p>A contemporary programming language for the discriminating programmer,
intended to approximate the safety of Haskell and the expressiveness
of Ruby. Should such an approximation turn out to exist.</p>

<h2><a href="http://noflojs.org/">NoFlo</a></h2>

<p>NoFlo is a JavaScript implementation of Flow-Based Programming (FBP).
Separating the control flow of software from the actual software logic.
Helping you organize large applications easier than traditional OOP
paradigms, especially when importing and modifying large data sets.</p>

<h2><a href="http://opalang.org/">Opal</a></h2>

<p>Opa is a full-stack open source web development framework for JavaScript
that lets you write secure and scalable web applications.
Opa handles all aspects of web programming: frontend (client code),
backend (server code) and database queries are all written in one
consistent language and compiled to standards of the web.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-17-September" title="September 17, 2013">September 17, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/09/04/Revelation-Knowledge/" rel="prefetch">Revelation Knowledge</a></h2>
            <p><p>I just had a revelation about programming languages.</p>

<p>Coming into this project, my primary goal was to rate a Forth derivative, that added types, polymorphism and functional-orientation to the language. That goal is proceeded reasonably well. However, in the course of thinking about all the varying aspects of the design I hit upon a very interesting concept. I asked, &quot;What does the computer know?&quot; In other words, how are we really informing the computer about our systems as we program. It only stands the reason that the more the computer knows the more we easily we can communicate our intent.</p>

<p>So lets start with the bread and butter the algorithm, and seeing that we want to stay in the realm of functional-programming ultimately will strictly speak of functions. But to proceed, lets get our barrings by asking what other languages tell the computer about such these things, whether they be procedures, functions or methods.</p>

<p>Forth is probably the most basic in this regard of all languages, with the exception of Assembly. It doesn&#39;t tell the computer anything at all about a <em>word</em> (Forth&#39;s term for these things) other then the procedure by which it is calculated. Some Forth words provide terse stack diagrams but they are simply comments, ignored by the computer.</p>

<p>Other languages, like Ruby, are essentially the same as Forth. Ruby is a dynamic language, so it doesn&#39;t provide types for method arguments. To a limited degree names are provided for them, but they are promptly thrown away by the interpretor, so the computer is no more knowledgeable in that regard either. We do get one piece of extra information though. We can ask Ruby what the arity of a method is.</p>

<p>Python takes us a tad step further with regards the argument names. One can pass arguments to a method by name. That&#39;s an improvement, but that&#39;s about as far as it goes.</p>

<p>On the other side of things, there are languages like Java which are very strictly typed. But the types do little more than inform the compiler how to do it&#39;s job better. In the language itself we can&#39;t really ask about them. The names of the parameters are still ultimately disposable to the computer. (I wouldn&#39;t be surprised if there is some insanely complicate reflection library out there for Java that would make some of this possible, but regardless it is not part of the <em>real</em> language.)</p>

<p>Then there are languages like Haskell which are strictly typed and can tell us all about those types. </p>

<p>Haskell&#39;s about the state of the art at this point. There isn&#39;t a language I know of that informs the computer more about it&#39;s functions.</p>

<p>So then I asked, what would be a <em>knowledgeable design</em> such that the computer would know about these things we computers use day in and day out, and really be able to converse with us about them, so to speak.
Well, lets break it down. What is there to know about a function?</p>

<ul>
<li>Arity</li>
<li>Types of the arguments</li>
<li>Types of the return values</li>
<li>Name of the function</li>
<li>Name of the arguments</li>
<li>Definition of the function</li>
</ul>

<p>Beside these, it may even behoove us to inform the computer about aliases for the various names, so it is easier to talk about these things for different programmers who might not be as with the code, or just to give us some programmer to speak more naturally, rather than always being so tortured to use the exact term.</p>

<p>Lets try and example, by writing out some pseudo-code for a function. Let&#39;s keep it simple, say, calculating the tip for a check.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">function tip(amount, percentage)
  typeof amount Currency
  typeof percentage Float

  default amount $0
  default percentage 20%

  aliases percentage percent pnct pct
  aliases amount price cost

  definition amount * percentage

  return-type Currency
end

aliases tip gratuity
</code></pre></div>
<p>But notice we also said &quot;tip <em>for a check</em>&quot;. That means something, so in our pseudo-code lets try to express that.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">context tip check

aliases check bill
</code></pre></div>
<p>Okay. So what do we have after all that? Well, at the very least we have a way to speak to the computer about the various parts of our function.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tip.parameters  =&gt; [amount, percentage]
tip.return_type =&gt; Currency
tip.parameter(amount).type  =&gt; Currency
tip.parameter(pcnt).default =&gt; 20%
</code></pre></div>
<p>And so on. We can also call the function of course, but we could do so in unique way now. We can do it in an object-oriented way. After we do have a <em>thing</em> that is our function.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">mytip = new tip
mytip.amount = $100.00
mytip.return  =&gt; $20
</code></pre></div>
<p>Now in the larger scheme of things, if that is all there were it might not get us too much further than the programming languages we mentioned above. But, we might now be able take all this new found knowledge granted to the computer about our program and start asking it to do some things we might normally do ourself.</p>

<p>For example, lets describe to the computer the concept of paying for lunch.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">function pay(bill, tender)
  type bill Bill
  type tender Currency
  definition
    tender - (tally + gratuity(pcnt: 20%))  # this right here!
  return-name change 
  type change Currency

object Bill(menu-items, tax)
  type menu-items List(Product)
  type tax Percentage

function tally(bill)
  type bill Bill
  definition
     net = sum(bill.menu_items.each.cost) 
     net + net * tax
  aliases tally price cost
  return-type Currency

object Product(name, price)
  aliases price cost
  type name String
  type price Currency
</code></pre></div>
<p>Look closely at the line <code>tally + gratuity</code>. Notice we didn&#39;t say <code>bill.tally + tip(bill.tally)</code>. Not I know my pseudo code doesn&#39;t really get us to the point where it&#39;s clear how we can be so concise. But I think the basic notion is there. The idea is that by explicitly defining the various parts of our model, drawing relationships between those parts via aliases then the computer itself can start to make the connections between the return values and the input parameters for us.</p>

<p>I suspect if this kind of approach is taken to it&#39;s natural conclusion, it should ultimately allow us to write much more reusable code, write that code in a much more natural and information rich manner.</p>

<p>Taking a step back, I believe it would be too much of undertaking for me to endeavor upon at this point. Nonetheless it does move me in a smarter direction with March --to make the language more knowledgeable.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-04-September" title="September 04, 2013">September 04, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/08/11/drink-me/" rel="prefetch">Drink Me</a></h2>
            <p><h1>Drink Me</h1>

<p><strong>A Case For and Against Elixir</strong></p>

<p>Is thinking functionally a bit of a black art?</p>

<p>As I explained in a previous post, I have been writing a genetic algorithm to find the best layout of a keyboard based on a set of ergonomic principles. I decided to write the program in both Go and Elixir as a way to &quot;learn me some new programmings languages for the greater good&quot;. Writing the Go program went very smoothly. I had a good working program in just over a day&#39;s work. The Elixir code on the other hand has taken me close to three days and I am still trying to work out issues. I attribute most of this long spell to the paradigm shift one must make when switching from a procedural to a functional way of doing things.</p>

<p>I have two examples from my work that I think demonstrate the difficultly of this shift.</p>

<p>Originally I had written the following code:</p>
<div class="highlight"><pre><code class="elixir language-elixir" data-lang="elixir">    <span class="k">def</span> <span class="n">evolve</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="k">do</span>
<span class="k">      </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span>

      <span class="n">best</span> <span class="o">=</span> <span class="m">0</span>
      <span class="n">size</span> <span class="o">=</span> <span class="m">16</span>

      <span class="n">pop</span> <span class="o">=</span> <span class="n">random_keyboards</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

      <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span> <span class="p">(</span><span class="m">1</span> <span class="o">..</span> <span class="n">gen</span><span class="p">),</span> <span class="n">pop</span><span class="p">,</span> <span class="k">fn</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">newpop</span> <span class="o">=</span> <span class="no">List</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">breed</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">newpop</span> <span class="o">=</span> <span class="n">natural_selection</span><span class="p">(</span><span class="n">newpop</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="n">first</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">childs</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best</span> <span class="o">&lt;</span> <span class="n">first</span><span class="o">.</span><span class="n">score</span> <span class="k">do</span>
<span class="k">          </span><span class="n">best</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">score</span>
          <span class="n">size</span> <span class="o">=</span> <span class="m">16</span>
        <span class="k">else</span>
          <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="m">2</span>
        <span class="k">end</span>         

        <span class="n">newpop</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>It all seemed rather reasonable to me. Turns out however, Elixir thought otherwise:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">variable best is unused
variable size is unused
</code></pre></div>
<p>My procedural mindset was geared toward the idea of using variables to track a state while iterating around in a loop. But for a functional language this is not the correct way to think about the problem. By reassigning best and size within the <code>reduce</code> block function I was in effect creating new variables, not reassigning the ones defined outside.</p>

<p>The solution, as is the case with many such procedural conversions, is to think recursively.</p>
<div class="highlight"><pre><code class="elixir language-elixir" data-lang="elixir">    <span class="k">def</span> <span class="n">evolve</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="k">do</span>
<span class="k">      </span><span class="ss">:random</span><span class="o">.</span><span class="n">seed</span>
      <span class="n">evolve</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">random_keyboards</span><span class="p">(</span><span class="m">16</span><span class="p">),</span> <span class="m">16</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="n">evolve</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">pop</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">best</span><span class="p">)</span> <span class="k">do</span>
<span class="k">      if</span> <span class="n">gen</span> <span class="o">==</span> <span class="m">0</span> <span class="k">do</span>
<span class="k">        </span><span class="n">pop</span>
      <span class="k">else</span>
        <span class="n">newpop</span> <span class="o">=</span> <span class="no">List</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">breed</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">newpop</span> <span class="o">=</span> <span class="n">natural_selection</span><span class="p">(</span><span class="n">newpop</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="n">first</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">childs</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">best</span> <span class="o">&lt;</span> <span class="n">first</span><span class="o">.</span><span class="n">score</span> <span class="k">do</span>
<span class="k">          </span><span class="n">evolve</span><span class="p">(</span><span class="n">gen</span> <span class="o">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">newpop</span><span class="p">,</span> <span class="m">16</span><span class="p">,</span> <span class="n">first</span><span class="o">.</span><span class="n">score</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">evolve</span><span class="p">(</span><span class="n">gen</span> <span class="o">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">newpop</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="m">2</span><span class="p">,</span> <span class="n">best</span><span class="p">)</span>
        <span class="k">end</span>         
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>After working this out, a part of me has to agree the fanboys of functional languages. This does smack of an certain elegance that the procedure solution lacks. The solution is also efficient thanks to <em>tail recursion</em>, which avoids the usual call stack overhead of repeatedly calling nested functions.</p>

<p>But then there was the routine that I have yet to figure out how to do in a more functional way. To get the following routine to work I basically had to make Elixir behave much like a procedural language --running in a loop shuffling list indexes around.</p>
<div class="highlight"><pre><code class="elixir language-elixir" data-lang="elixir">    <span class="k">def</span> <span class="n">cross</span><span class="p">(</span><span class="n">mother</span><span class="p">,</span> <span class="n">father</span><span class="p">)</span> <span class="k">do</span>
<span class="k">      </span><span class="n">offset</span> <span class="o">=</span> <span class="m">0</span>

      <span class="k">if</span> <span class="n">numeric_layout?</span><span class="p">()</span> <span class="k">do</span>
<span class="k">        </span><span class="n">offset</span> <span class="o">=</span> <span class="m">9</span>
      <span class="k">end</span>

      <span class="n">n</span> <span class="o">=</span> <span class="n">number_of_actions</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>  <span class="c1"># 0 or 1</span>

      <span class="n">child_layout</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span> <span class="p">(</span><span class="m">0</span> <span class="o">..</span> <span class="n">n</span><span class="p">),</span> <span class="n">mother</span><span class="o">.</span><span class="n">layout</span><span class="p">,</span> <span class="k">fn</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="ss">:random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="n">l</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">at</span> <span class="n">father</span><span class="o">.</span><span class="n">layout</span><span class="p">,</span> <span class="n">i</span>
        <span class="n">x</span> <span class="o">=</span> <span class="no">Enum</span><span class="o">.</span><span class="n">find_index</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">fn</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">q</span> <span class="o">==</span> <span class="n">l</span> <span class="k">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="k">do</span>
<span class="k">          </span><span class="n">swap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">c</span>  <span class="c1"># should generally never happen</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="n">make_keyboard</span><span class="p">(</span><span class="n">mutate</span><span class="p">(</span><span class="n">child_layout</span><span class="p">))</span>
    <span class="k">end</span>
</code></pre></div>
<p>Perhaps it is inevitable that some procedural-esque code will always be present. In fact, that is the one caveat about functional programming that makes me wonder if maybe it&#39;s <em>not quite all that</em>. Some problems, that are relatively easy to solve in a traditional procedural language, seem markedly harder to solve functionally.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-11-August" title="August 11, 2013">August 11, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/08/06/Should-You-Go/" rel="prefetch">Should You Go</a></h2>
            <p><h1>Should You Go?</h1>

<p><strong>2012-080-06 [DRAFT]</strong></p>

<h2>Preface</h2>

<p>I&#39;ve been working on a (somewhat esoteric) IME for Android over that last couple of years and recently I decided to automate part of my design process. I had been manually evaluating keyboard layouts for ergonomic quality. After expending so much time and energy into evaluating one layout after another, trying to ascertain which is optimal in my mind without coming to any firm conclusion, I decided something had to give. And so I did what a coder does best: I wrote a program to figure it out for me. The idea was straight forward. I would codify the principles by which an ergonomic layout is to be judged, assign a score to each of those principles, and then have the computer shuffle through every permutation to find the one with the highest score.</p>

<p>Thanks to its elegance and my high fluency in Ruby, I was able to whip out an initial working program in a few hours, and by the end of the day I was getting useful results. Unfortunately there was a problem. It was <em>Way Too Slow</em>. The first culprit, it become clear, was that a brute force search wasn&#39;t going to suffice. There were simply too many possibilities. To remedy that I added a simple genetic algorithm and seeded it with an initial population of layouts I already knew to be pretty good. That helped a lot, but it was still <em>Way Too Slow</em>. So then I decide to turn this new problem into an opportunity. And that&#39;s where this story gets interesting...</p>

<h2>Learning Go</h2>

<p>I&#39;ve been wanting to learn a new modern programming language for a while. Having a relatively small yet substantial problem to solve made for the perfect excuse. After doing some research on Go, Julia, Haskell, Erlang and Elixir --all languages I expected to offer me a nice bump in speed (wait, isn&#39;t that just about any language compared to Ruby?) I narrowed my choices to Elixir and Go. I choose Elixir because it was a <em>functional language</em> but borrowed much of it&#39;s syntax from Ruby. That would make the transition easier. And I choose Go because it was a lower-level language, potentially offering the greatest speed gain. I&#39;ve always hated C and I will never endeavor to be proficient in it. But Go presents a much more approachable way to program that is fairly close to the metal like C. So I am pretty tickled by its prospects. I dived into the Elixir first, but I will save my thoughts on Elixir for a future post. The rest of this article will cover my initial thoughts on Go.</p>

<h2>Initial Impression</h2>

<p>If I were to sum things up as concisely as possible I would say this about Go: &quot;The really good thing about Go is that there is so little to it. The really bad thing about Go is that there is so little to it.&quot; That is very accurate. In Go, I had to write a function to scan an <em>array of string</em> for members. I stress &quot;array of string&quot;, because, you guessed it, one would have to write a completely separate function for <em>array of int</em>. Go has no general functions. Every function is type specific to its very bones. Many a questions on the golang-nuts mailing list ends with the post &quot;There is no general solution...&quot;. It really does seem crazy how many hoops one has to jump through to get things done. What would be a clear one-liner in Ruby, well, it will take at least a handful of lines in Go. In the future, I truly expect to hear old-time Go coders swapping legends about maintaining million lines of code. (Just like old times!)</p>

<p>But!!! (<em>triple exclamation</em>) There is a silver lining. As awful as all that sounds, the downright <em>simplisticness</em>(TM) of Go does have two really great benefits. First, there isn&#39;t much to learn with respect to the language itself. It literally takes a day to learn the basic constructs and to get up and running at a pretty good clip. Secondly, because every itty-bitty routine must be coded there is hardly any doubt as to exactly what the code is doing and there is plenty of room for optimization all along the way. This is one of the things that makes Go code so fast. Granted it leaves room for a poor coder to write less than optimal code too, but Go Trusts You. On the whole the extreme simplicity of the language is a net positive.</p>

<p>Beyond that, coding in Go was fairly comfortable. The syntax is actually harder to read than it is write, as strange as that sounds. After writing Go code for just for a short while, it starts to feel very natural, which probably accounts for why I was able to write my program in just over a day, despite never having written a lick of Go before. In particular I have to give props to Go&#39;s <code>for</code> loop construction. The whole <code>for i, x := range anarray { ... }</code> thing makes writing most loops a breeze.</p>

<h2>Case-for-Visibility</h2>

<p>One reason the code might be a little hard to read is Go&#39;s use of function name capitalization to &quot;export&quot; a package&#39;s public interface. There is a part of me that wants to agree with other that this is stroke of Genius. Many Rubyists feel the same about the capitalization of Class names. However, when ever I see capitalization being made significant in a language a little red flag goes off in the back of my head. Upon a more tempered consideration, it is perhaps easy to see why. The designers <a href="http://golang.org/doc/faq#unicode_identifiers">admit</a> this is an issue for those who code in certain foreign languages. But they also say, &quot;the case-for-visibility rule is unlikely to change however; it&#39;s one of our favorite features of Go.&quot; It would seem the designers might need a lesson on the <a href="http://www.fastcompany.com/1802659/letter-editor-adrien-brody-rule">Adrien Brody Rule</a>. If it were only a convention it might be passable. But forcing it is really unacceptable for wider use as a global programming language. And personally, after the initial coolness wore off, I began to think it just looks bad. Alongside Go&#39;s CamelCase convention (and you kind of have to do that once you require capitalization), you end up with  somewhat ugly, &quot;Visually Basic&quot; looking code. Clearly they missed the Ruby memo: When it comes to readability, <code>foo.make_something_good</code> beats <code>foo.MakeSomethingGood</code>.</p>

<h2>Project Structure</h2>

<p>Another significant issue with Go is its standard project structure. Essentially it pushes the <em>one giant workspace</em> approach to development (see http://golang.org/doc/code.html). That might make sense for a software development house, but for other types of coders that is really not acceptable. I sometimes have projects where the code is just an auxiliary aspect. The project could have presentations, spreadsheets, word documents, etc. If there is code associated with the project it needs to reside alongside these other documents and not be handicapped for doing so. Currently the only way I see for doing this is to adjust the $GOPATH every time I work on such a project. No fun. Hopefully there is a better way yet too be discovered, or that the Go designers will eventually provide.</p>

<h2>Debugging</h2>

<p>From what I thus surmise about the tools provided for Go, I have only scratched the surface of what is available. But I can say that one the best things about working with Go were the very clear and directory error reports. By default, at least, Go doesn&#39;t fill the screen with stack traces and code snippets. Rather is simply states the problem in plain English and give the file and line number where it arose. The clarity of the error messages made it very easy to correct every issue detected by the compiler.</p>

<h2>Documentation</h2>

<p>With regards to documentation, I have to give Go a push. What is available is still quite weak. However, given how new the language is, the current state of documentation is actually rather commendable. With its growing popularity, clearly this is a situation that will improve rapidly.</p>

<p>Einstein had a saying, &quot;Everything should be made as simple as possible, but not simpler&quot;. In some respects, such as the generics issue, Go has made things <em>too</em> simple. If Go&#39;s designers ultimately find a way to support generics --and by all accounts they are at least <a href="http://golang.org/doc/faq#generics">open to the prospect</a>, the language would become much more accessible. And some of this critique will be mitigated. But despite it&#39;s over simplification, it beats the pants off the converse issue over complexification, which we too often find in other languages.</p>

<p>Go is the best new language to come along since I learned Ruby in 2002. I think anyone still coding C when it&#39;s not absolutely necessary, is just a glutton for punishment. I highly recommend you Go, and Go now.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-06-August" title="August 06, 2013">August 06, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/08/05/memory-frabrics/" rel="prefetch">Memory Frabrics</a></h2>
            <p><p>I&#39;ve been thinking about data structure the last week, and I was wondering why data structures are implemented the way they are.</p>

<p>It occurs to me that it is mostly due to the way computer memory is designed. Computer memory is a randomly accessible linear structure. Basically what you have is a large string of values that you can access by a single position index. This is the <em>interface</em> of memory, and all data structures are there root must use it in their implementation.</p>

<p>But I wondered, how would data structures differ is memory itself was structured in some other fashion? For instance, what if memory wasn&#39;t a linear string of data, but a two-dimensional fabric? While arrays might be unaffected by such a change, clearly things like matrices could be stored in a much more literal fashion. It would be interesting to see the form of data structure talented individuals might devise with this.</p>

<p>Even so, two-dimensions is still somewhat limiting, taking it to a third dimension could open tremendous possibilities in the <em>relative storage</em> of data.</p>

<p>But might we go even further. What would prevent us from making the dimensionality definable? If a memory cell could be associated with any other memory cell as often as desired, then the <em>fabric</em> could have any structure desired. Interestingly, the effect of this would be to move what we already do in software, via indirect memory referencing, to the hardware itself.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-05-August" title="August 05, 2013">August 05, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/03/08/ruby-avoids-consistency-like-the-plague/" rel="prefetch">Ruby Avoids Consistency Like The Plague</a></h2>
            <p><h1>Ruby Avoids consistency like the Plague</h1>

<p>Ruby is such a great language in so many ways, it always feels especially disappointing when one discovers a way in which it lacks. I believe much of Ruby&#39;s less noble attributes stem from a single source: Matz and company eschew <em>consistency</em> as if it were a disease.</p>

<p>Let&#39;s take a simple example that occurred to me today as I was working on a <a href="http://rubyworks.github.com/mirror">reflection</a> system for Ruby. It has probably slipped by every Rubyists on the planet, but once it is pointed out, it&#39;s pretty obvious. A <em>class</em> has <em>instance methods</em> of which we can get a list via the <code>#instance_methods</code> method, as opposed to an <em>instance</em> of a class whose methods we can list via <code>#methods</code>. That in itself might be an acceptable naming system accept the instance also has a method called <code>#instance_variables</code> (not to mention a number of other &quot;instance_&quot; methods). Give it a moments though and it becomes clear that the terms don&#39;t jive well. The problem lies in the fact that classes don&#39;t actually have &quot;instance methods&quot; per-se. They have <em>method definitions</em> that become instance methods when a class is instantiated. It would have made much more sense for the class&#39;s method to called <code>#methods</code> and the instance&#39;s to be called <code>#instance_methods</code>. Or, at the very least, the class terminology could have used something else like <code>#method_definitions</code>.</p>

<p>Generally we developers just accept APIs as they a given us and go about using them without giving too much thought to the nomenclatures used. Unfortunately inconsistent terminology often leads to difficulties communicating with other developers, ultimately wasting time and energy. The above is just one example of such an inconsistency. But don&#39;t bother telling Matz or the rest of the Ruby core team. They will just tell you &quot;consistency is as a bad reason for language change&quot;. Perhaps in the short-term that is true to avoid backward compatibility issues. In the long-run, however, it&#39;s only a matter of time before people head to greener pastures.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-08-March" title="March 08, 2013">March 08, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2013/02/28/the-end-of-ruby/" rel="prefetch">The End Of Ruby</a></h2>
            <p><h1>The End of Ruby</h1>

<p>I have given 10 years of my life to Ruby. And in return I have been ridiculed, mocked, cussed at, laughed at, shunned, harassed, ignored and all but excommunicated from the Ruby community. And all for nothing more than trying to be a helpful and constructive part of it. </p>

<p>Let me be clear. I am not a saint. Lord knows I can get emotional and put my foot squarely in my mouth at times. I have not always been the nicest guy. But I can tell you I have tried to be, and when I haven&#39;t it has been in reaction to others poor behaviour. And when I have found myself going too far I apologize. I don&#39;t hold grudges, I am gracious about being proven wrong and I always work with people as professionally as I can, even with people I basically can&#39;t stand (b/c of the way they have treated me).</p>

<p>I suppose it all started with GUtopIa. Long ago, when I first learned Ruby I wanted to create a very cool Ruby GUI that provided an unified interface to any GUI back-end (Gnome/GTK, KDE/Qt, Fox, tcl/tk, etc.) Some others were enthused about the project and we began to discuss privately. Having initiated the project I just assumed a leadership roll and began working out how to proceed. At the time I didn&#39;t really understand that I was in over my head (I was decent procedural programmer, but had zero OOP nor Agile experience.) This presumption irked a few a people and Rich Kilmer emailed me a lovely message letting me know that they &quot;did not work&quot; for me. I was a bit taken aback. I did not mean to come off that way and apologized, but it was too late. They informed me that they would be working a WxWidgets binding instead. It was a valuable lesson. And while I would like to think my apology was accepted, those initial ill feelings could have carried on into the community. I have no way to know. </p>

<p>Other then a few sometimes mildly heated arguments. I imagine some people disliked me b/c I was willing to argue a point in great detail and at length. I can see how that would be frustrating on the other end. But among those individuals --David Black, Ara Howard, Austin Ziegler, Guy Wright, and so on, despite what they might have felt about me personally, they maintained a high level of professionalism, put heated debates in proper context and moved on cooperatively with the shared of endeavour of being and becoming great Rubyists.</p>

<p>Bu then there was Ryan Davis. The first thing Ryan Davis ever said about me (AFAIK) was a <a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/215440">slander</a> of my first two Ruby projects.</p>

<blockquote>
<p>&quot;No, I never looked at reap. I wouldn&#39;t touch it or facets with someone else&#39;s ten foot pole.&quot;</p>
</blockquote>

<p>Sounds like an objective point of view, doesn&#39;t it? He hadn&#39;t even looked at the project but he knew he wouldn&#39;t touch it. Why the prejudice? I had no idea. But I would later come to understand that it actually had nothing to do with code. Reap and Facets were the first two open-source projects I had ever attempted to personally maintain in my life, and at that time they hadn&#39;t been out long. Both were early in their 0.x series of release. So I accepted the criticism, despite its nonconstructive form and worked to make my projects better. And with time, the quality and quantity of project continued to improve. But the way I was treated did not.</p>

<p>I submitted a patch to RubyGems once to allow a list of resource links in the gemspec, e.g. <code>home</code>, <code>docs</code>, <code>wiki</code>, <code>issues</code>, etc. Ryan did nothing but tear it apart, offering little in the way of constructive advice, but spilling slurs and curse words throughout his line by line &quot;critique&quot;. When I responded --in order to have a <em>dialog</em> about why I coded things the way I did, he only became more vitriolic. A comment he posted, containing a dialogue he had with a colleague of his (most likely Aaron Patterson), in some ill attempt to justify his behaviour:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">5:13:17 PM Professor: he tried to defend every single one
5:13:26 PM Professor: none of them he went &quot;ok, thats fine, i&#39;ll do it that way&quot;
5:13:28 PM zenspider: he needs to learn how the fuck to take critiques
</code></pre></div>
<p>It would seem he and his company think dialog is nothing more than a questioning of their authority.
Perhaps it would seem ironic then that once again I did accept every critique (that is the actual ones which were mostly provided by Eric Hodel), whether I agreed with it or not (I had no avenue for discussing it), and made a <a href="https://github.com/rubygems/rubygems/pull/15">new patch</a> that addressed every point. And though I specifically asked that anyone but Ryan Davis review it, I and the patch were ignored. Months later the request was closed with only a small comment from Ryan Davis, &quot;Looks like this is dead.&quot; To this day the gemspec does not support links, and one must still enter them by hand on rubygems.org.</p>

<p>Eventually I learned that Ryan Davis and Aaron Patterson are co-workers, and along with Eric Hodel they are the leading members of a club called <a href="">Seattle.rb</a>. While greatly gifted as developers, they are also notoriously arrogant. They have demonstrated this time and again and in numerous ways. From simply failing to comment their code to ganging up on some poor coder just trying to be constructive. One of their favourite tactics is to gang up on others, making it look like independent analysis through the visor of the Internet, when in fact it is per-determined plan. Unfortunately this group has systematically taken over much, if not most, of Ruby&#39;s development. They hold great power over MRI now, and they control most of the major projects of the standard library --RubyGems, Nokogiri, Psych, RDoc, etc.</p>

<p>&quot;But what about Matz?&quot; I hear you ask. &quot;Surely he remains in firm control?&quot; Every one knows Matz is a nice guy, and that is true. Matz has always been a nice guy. But Matz has also always been a very passive personality. No one is perfectly nice. So I suspect Matz&#39; outlet is classic passive-aggressive behaviour. A good example of this is his complete avoidance of the <a href="https://bugs.ruby-lang.org/issues/7716">autoload issue</a>. Even though he announced over a year ago that &quot;autoload will be dead&quot;, none of the code in the standard lib has made any changes to remove it. When asked, the maintainers said they had no plans to do so. I have been asking for <em>five years</em> for the simplest of patches to fix this issue --I even submitted a patch myself and I am not a C coder, but never has it been addressed. I have email Matz directly and received no response. To this day I have at least three programs that can not be fully utilized because of it. So, a nice as Matz might be, he lacks the requisite character to be a strong leader to enforce professionalism among those he deem technically merited to work on Ruby. </p>

<p>...</p>

<p>The last straw..</p>

<p>Sometime ago I improved the design of FileUtils a good bit and <a href="https://bugs.ruby-lang.org/issues/4970">submitted a patch</a> to ruby-core. I did so because Ruby Facets adds a couple of extensions to FileUtils, and they way the code had been written made it very cumbersome to do so properly. The patch was review and accepted.</p>

<p>Last week Eric Hodel found an subtle bug in the code --none of the tests caught it. The problem was easy enough to ascertain and to fix. I actually offered an idea for a solution that would actually make the code even better. Again there was no dialog. I was ignored. Eric sanctimoniously appointed himself maintainer for fileutils.rb and decided to revert all the improvements back to the old code. Despite the fact that the new code already went out with Ruby 2.0 preview release (so much for &quot;feature freezes&quot;). Despite the fact the the new code is far superior to the old (<a href="http://bugs.ruby-lang.org/projects/ruby-trunk/repository/revisions/39544/diff/lib/fileutils.rb">compare for yourself</a>). And despite my objections. There is only one reason Eric reverted that code. To spite me. </p>

<p>He would deny it, of course. But the evidence is clear enough. Why no dialog? Why such a drastic reversion of clearly improved code that passes all tests? Why was Aaron the only other person to comment with out any constructive thing to say, just a &quot;yea do it&quot;. Taken in conjunction with the combined history of this groups persecution of me, the answer is obvious.</p>

<p>When a project begins reverting released code solely on the basis of personal vindictiveness, that project is on a fast track to doom. Ruby has become such a project. I am not the <a href="http://news.cnet.com/8301-13846_3-9838477-62.html">first to see it</a>, or the first to <a href="http://www.rubyinside.com/why-the-lucky-stiff-is-missing-2278.html">react to it</a>, and comments about it are only increasing.</p>

<ul>
<li>http://www.jperla.com/blog/post/ruby-is-a-ghetto</li>
<li>http://gilesbowkett.blogspot.com/2013/02/nodejs-hatred-reveals-significant.html</li>
<li>http://www.zohararad.com/2012/11/16/10-reasons-not-to-use-ruby/</li>
<li>http://drbacchus.com/geek-arrogance-and-chauvinism</li>
<li>http://blog.majesticseacreature.com/rubygems-nerd-rage-is-optional-and-discourage</li>
</ul>

<p>That main clique now running the roost are arrogant ingrates, rude and vindictive. They are utterly lacking in professionalism. I have no doubt some people will want to disagree --most of whom have not had enough interaction with these individuals to really know them. But enough people have seen it and have remarked on it.</p>

<p>https://gist.github.com/tenderlove/92f5a886fd9dafba1685</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2013-28-February" title="February 28, 2013">February 28, 2013</time>
            </div>
        </div>
        <hr>
    </section>
    
    
    <section class="pagination" style="text-align:center">
      
      
        <a href="/page2" class="btn btn-outline">Older ›</a>
      
    </section>
</article>


<footer class="site-footer">
    <div class="container">
        &copy; 2014 
        
        <nav>
            <a href="http://transcode.github.com">TRANS</a> &middot;
            <a href="/">Blog</a> &middot;
            <a href="http://github.com/trans">Product</a> &middot; 
            <a href="/About/">About</a>
        </nav>
        
        <nav class="social">
            
            <a href="https://twitter.com/transgigamic" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter black"></i></a>
            
                
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss black"></i>
            </a>
        </nav>
        <p>Incorporated theme by <a href="https://sendtoinc.com">Inc</a></p>
    </div>
</footer>

<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="/assets/main.js"></script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
    (function(d, t) {
        var g = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        g.src = '//hnbutton.appspot.com/static/hn.min.js';
        s.parentNode.insertBefore(g, s);
    }(document, 'script'));
</script>


</body>
</html>
