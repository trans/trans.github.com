
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Transcode Blog</title>
 <link href="http://trans.github.com/atom.xml" rel="self"/>
 <link href="http://trans.github.com"/>
 <updated></updated>
 <id>http://trans.github.com</id>

 
 <entry>
   <title>A Second Look at Bundler</title>
   <link href=""/>
   <updated>2010-05-19</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p><b>DRAFT</b></p>

<p>A few days ago I wrote an article on my concerns with Bundler. Since then I've received enough feedback to refine my thoughts. My opinion that the Ruby/Rails community is on a "crazy train" with regards to Bundler stems from the level of COMPLEXITY it further adds to the development and deployment process. Of course, it's intent is to do just the opposite. But that's the danger of new technologies that we must always be cautious about --there are always unexpected consequences. So, taking the feedback into account, here's a better breakdown of the ups and downs of Bundler as I now see them.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>Gem Crazy</title>
   <link href=""/>
   <updated>2010-05-15</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p><b>I believe the Ruby community may have finally gone off the rails in it's collective
crazy train.</b> I have been reading about <a href="http://gembundler.com/">Bundler</a>,
the spiffy new RubyGems manager to be default part of Rails 3.0, and I can't help but
wonder what track we were even on.</p>

<p>If you don't know about Bundler yet, you can learn about it
<a href="http://yehudakatz.com/2009/11/03/using-the-new-gem-bundler-today/">here</a>.
I imagine most of you are already aware of it and are now considering how it fits in
with your future development plans. So I want so ask a more fundamental question:
Why does Bundler even exist?</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>A Case for Module Inheritance</title>
   <link href=""/>
   <updated>2010-04-13</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p>I love beautifully written code. Unfortunately the realities of the
language sometimes clash with requirements of the implementation. While
Ruby goes a long way toward making beautifully written code common place.
It still has some shortcomings I'd like to see improved.</p>

<p>Case in point are my endeavors of the last few days. I've been struggling
to re-structure the code of the <a href="http://github.com/rubyworks/english/">English</a>
project. The primary purpose of the project is to provide extension methods to String,
pertaining to the English language. A good example are number inflection
methods #singular and #plural. At the same time I am trying to design
the library in such a way that other language modules can be built following
the same basic structure, and they could all work together if need be.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>Code Identity</title>
   <link href=""/>
   <updated>2010-02-25</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <h1>A Little Fun with Code Generation</h1>

<p>A couple of years ago, a
<a href="http://blade.nagaokaut.ac.jp/cgi-bin/vframe.rb/ruby/ruby-talk/293058?292931-293646+split-mode-vertical">Ruby Quiz</a>
asked us <i>to print "Hello, world!" to standard output using Ruby in atypical fashion.</i>
Being the resolute over-achiever-to-a-fault that I am, I decided to take the proverbial
pie-in-the-sky highroad to metaland. If, I thought, I could define code <i>identities</i>,
akin to the mathematical kind, I should be able to have the computer simply
generate an endless stream of equivalent solutions. Indeed, it turned out that it wasn't
all that hard to code.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>A Failure of Precedence</title>
   <link href=""/>
   <updated>2009-12-13</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <h1>Ruby's Operator Precedence Can Be Improved</h1>

<p>There's a lot to love about Ruby. Most of us know well the many great advantages it provides, as they
say, "making programming fun". However, Ruby is also notoriously dogged by a few small gotchas and inconsistancies.
Some of these are understandable, such as the <a href="http://eigenclass.org/hiki/The+double+inclusion+problem">Double Inclusion Problem</a>;
issues that are not worth the extensive effort to fix. On the other hand, some simple issues doggedly persist for little good
reason (backward compatibility not withstanding).</p>

<p>One of these issues is operator precedence. Not only is operator precedence set in stone, it is also
woefully <i>bottom heavy</i> --there is only one binary operator available for use above the common arthmetic operations.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>This is Exciting!</title>
   <link href=""/>
   <updated>2009-08-24</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <h1>Another Static Website/Blogging Tool</h1>

<p>If you were wondering, you are reading the old TigerOps.org blog. I have discontinued that
Wordpress-based blog due to spam overload, and have replaced it with this new site. Rather
than use Wordpress, this site is now running on <a href="http://proutils.github.com/brite">Brite</a>,
a home grown static website and weblog construction tool.</p>

<p>Now I know there are plenty of these out there, in particluar you have the <a href="http://github.com">GitHub</a>
backed <a href="http://wiki.github.com/mojombo/jekyll">Jekyll</a> and the very nicely designed
<a href="http://www.matthias-georgi.de/shinmun">Shinmun</a>, not to mention some of the senior tools
like <a href="http://webby.rubyforge.org/">Webby</a> and <a href="http://rote.rubyforge.org/">Rote</a>.
So, why do we need yet another? The reasoning is essentially two-fold.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>WxRuby for the Lazy</title>
   <link href=""/>
   <updated>2009-06-07</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p><a href="http://wxruby.rubyforge.org/wiki/wiki.pl">WxRuby</a> is probably the best overall GUI library for Ruby currently available. It is cross-platform, provides native look-and-feel and is stable enough for production use. All other GUI libraries, despite their various merits, fall short in at least one of the areas. However, WxRuby does have one major downfall. It is pretty much a straight port of the C API. Writing WxRuby code is largely the same as writing actual WxWidgets C code. It's far from the "Ruby Way".</p>

<p>So how did I mange to get fairly nice Ruby code despite a binding that is essentially a straight port of the underlying C API? I built it from the bottom-up using a lazy coding technique. And I mean "bottom-up" literally --the following code might actually be easier to read if you start from the bottom and work your way up to the top. The trick is to break down one's interface into individual widgets and create an instance method for each using the <code>||=</code> memoization trick.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>GUtopIa Revisited</title>
   <link href=""/>
   <updated>2009-03-20</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p>Recently I had to buckle down and create and honest to goodness desktop GUI application in Ruby. So once again, after some six years, I set down to weigh my options. It saddens me to say, after all these years, the state of desktop GUI programming with Ruby is still a rather sorry affair. Yes, there have been many improvements --thanks to the hard work of many a good programmer, but the task of creating a Ruby-based GUI application still remains a very non-Ruby-esque ordeal.</p>

<p>My first attempt at it this time was with <a href="http://shoooes.net/">Shoes</a>. Shoes is a new and very nice GUI engine written largely from scratch by the well known WhyTheLuckyStiff. It's a noble effort and some really <a href="http://the-shoebox.org/">neat programs</a> can come from using Shoes. Unfortunately for my needs Shoes proved to be too buggy and immature --at times I saw visual artifacts and there are a very limited number of controls. And worst of all, the fact that it includes it's own Ruby interpretor and manges it's own gems caused it not to work well with some other libraries. For instance, I could not get it to use the latest version of Mechanize.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>XML+CSS</title>
   <link href=""/>
   <updated>2009-02-10</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <h1>The Future of Web Design?</h1>

<p>In a <a href="http://tigerops.org/2009/01/mf-vs-xml.html">previous post</a>, I point out that microformats bring an additional layer of useful information to a document, which I dubbed <em>semantic structure</em>. In short, HTML tags provide useful <em>type</em> information about the data they contain. A good example of this has been the insistent push to use <code>div</code>s rather than <code>table</code>s for page layout. The reason is that tables describe a semantic structure, a table of data, and not layout. I for one have found this a frustrating haggle in the design of my pages. Time and time again I have been stymied by unwieldy <code>div</code>s. Tables are much easier to use, despite additional verbosity. But I have stuck to <code>div</code>s because it is "the right thing to do". Thankfully my saving grace will soon be here. The 3rd revision the CSS standard supports a new <code>display</code> style. With it, one can specify that a div is to behave like a table, table row or table cell. Woohoo! Three cheers for tabley divs!!</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>What's &micro;F got on XML?</title>
   <link href=""/>
   <updated>2009-01-24</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p>Decisions, decisions. Therein lies the reason why convention over configuration is so bloody great, precisely because it requires fewer decisions. <a href="http://proutils.rubyforge.org/syckle">Syckle</a>, my humble build tool, outputs log files. Yea, logs are good. But the decision I have to make is, "in what format?"</p>

<p>Now old-school would just put out some asterisk-studded text files with plenty of precise timestamps, maybe some nice long lines of dashes to divide things up. No doubt these files are easy to access and fairly readable. We like out text files. But hey wait. This is the age of magical markups. At the very least we can coax that log into a Wiki-tongue. For us Rubyists, we have rdoc, markdown and textile's just a few gemy fingertips away. These formats can be even easier to read thanks to structural consistency from log to log. Plus, fire-up a web server and we can get some really nice looking HTML too. That's the beauty of Wiki Wiki markup after all.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>The YADSL Rule</title>
   <link href=""/>
   <updated>2008-11-04</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p>Looks like the Ruby world is a fire with new DSLs for BDD/TDD. There's
<a href="http://rspec.info/">RSpec</a>,
<a href="http://blog.zenspider.com/minitest/">minitest</a>,
<a href="http://test-unit.rubyforge.org/test-unit/">Test::Unit 2.x</a>,
<a href="http://test-spec.rubyforge.org/test-spec/">test-spec</a>,
<a href="http://www.oreillynet.com/ruby/blog/2008/02/assert2.html">Assert 2.0</a>,
<a href="http://expectations.rubyforge.org/">Expectations</a>,
<a href="http://github.com/aslakhellesoy/cucumber/tree/master">Cucumber</a>,
<a href="http://github.com/carlosbrando/remarkable/tree/master">Remarkable</a>,
<a href="http://www.thoughtbot.com/projects/shoulda/">Shoulda</a>
... woulda, coulda ... My word! So many choices. It's fitting that
it's Thanksgiving, what we have here is a <i>cornicopia of framework</i>!!!</p>

<p>Uh... Okay, you'll have to forgive me. I get carried away.</p>

<p>I suppose it all started with that RSpec. Those guys built an incredibly
elaborate nomenclature to help us spell out our code's behaviors in gruesome
detail. But as wonderfully grandiose as it may be, there's just one tiny little
itty-bitty problem... <i>I can't remember it</i>. Oh, sure, I could sit down and
jam it into my already overloaded brain somewhere, but you know what. I ain't
gonna. I already have enough new stuff to learn and I'm not going to bother to
learn another DSL when those I already know work just as well.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>This Old Hash</title>
   <link href=""/>
   <updated>2008-10-06</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p>The Hash may well be the most used class in Ruby. Sure, our programs
have arrays and strings galore, but they generally come and go without
much ado. Hashes on the other hand get <em>used</em>; and by that I mean to
say, we spend a lot of time fussing with them. I think there are two
significant reasons for this and I will focus on the first, and
the more important of the two, here.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>If and OOPy If</title>
   <link href=""/>
   <updated>2008-09-28</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <h1>An Ally OOP for If-Conditions</h1>

<p>Ruby takes a unique approach to conditional evaluation: <i>All
objects are equivalent to <code>true</code> except <code>nil</code>
and <code>false</code></i>. No doubt this is a more object-oriented
approach than, say, C's use of <code>0</code> as false, but it's far
from the ideal of OOP all the way down, as any
<a href="http://pozorvlak.livejournal.com/94558.html">Smalltalker</a>
can attest.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 
 <entry>
   <title>Taskable</title>
   <link href=""/>
   <updated>2008-09-12</updated>
   <id>http://trans.github.com</id>
   <content type="html">
     <p>On more than a few occasions I have taken a stab at writing a general
purpose task system, akin to Rake's, but one that works within the
framework of Ruby class inheritance. I recall my first attempt was
quite an unwieldy beast, and my subsequent attempts were fairly
unwieldy too, but over time they became more concise. Below is the
most concise variation yet, and I was wondering what other thought
of it -- do you see any flaws in the design; does it satisfy all the
criteria of such a system; would you find it useful; etc.</p>

     [<a href="">Read More</a>]
   </content>
 </entry>
 

</feed>

