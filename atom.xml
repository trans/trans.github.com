
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>blog.crantastic.org</title>
 <link href="http://blog.crantastic.org/atom.xml" rel="self"/>
 <link href="http://blog.crantastic.org/"/>
 <updated></updated>
 <id>http://blog.crantastic.org/</id>

 
 <entry>
   <title>This is Exciting!</title>
   <link href="2009/09/new-website.html"/>
   <updated>2009-08-24</updated>
   <id></id>
   <content type="html"><h1>Another Static Website/Blogging Tool</h1>

<p>If you were wondering, you are reading the old TigerOps.org blog. I have discontinued that
Wordpress-based blog due to spam overload, and have replaced it with this new site. Rather
than use Wordpress, this site is now running on <a href="http://proutils.github.com/brite">Brite</a>,
a home grown static website and weblog construction tool.</p>

<p>Now I know there are plenty of these out there, in particluar you have the <a href="http://github.com">GitHub</a>
backed <a href="http://wiki.github.com/mojombo/jekyll">Jekyll</a> and the very nicely designed
<a href="http://www.matthias-georgi.de/shinmun">Shinmun</a>, not to mention some of the senior tools
like <a href="http://webby.rubyforge.org/">Webby</a> and <a href="http://rote.rubyforge.org/">Rote</a>.
So, why do we need yet another? The reasoning is essentially two-fold.</p>

<ol>
<li><p>I am a knit pick. With each alternitive I found a few nagging points upon which I
wanted to see a different approach taken.</p></li>
<li><p>I wanted to see if I could push the boundries, absorbing what good I may from
earlier systems (including my own stalled attempts) and contruct something
more intuitve and yet more powerful.</p></li>
</ol>


<p>With inline formats I think Brite has achieved that. You can easily have multiple types
of markups in a single page, in an elegant and relatively unobtrusive manner. (Yea, Wow!)</p>

<p>For example the document I am currently writing is in Markdown format. But...</p>

<p>This is using textile, and&#8230;</p>
<p>
This is using RDoc&#8217;s Simple Markup format.
</p>


<p>And this is raw HTML.</p>


<p>Furthermore, formats are plugable. We already have <a href="http://coderay.rubyforge.org">Coderay</a>
syntax highlighter support and are looking to add MathML support soon too. So this feature
allows for some truly amazing quick and easy contruction of web documents.</p>

<p>Another innovation of Webrite is the non-separation of markup files from their
generated output. This means one does not have to worry about dealing with source
subdirectory and site desitnations and the copying static files. All the files stay right
where they are frist created. The markup files use special extensions (.post, .page, .layout)
to differentiate then from the .html results. One simply filters the list of files when
publishing.</p>

<p>Webrite is still in the very early stages of development. It still needs features such as
pagination and tagclouds. But it is coming along rapidly, and I look forward to what is
coming downt he road. Future innovations may include <em>aquisition</em> (a la Zope and UserLand Frontier),
as well as a realtime Rack-based server.</p>
</content>
 </entry>
 
 <entry>
   <title>WxRuby for the Lazy</title>
   <link href="2009/06/wxruby-for-the-lazy.html"/>
   <updated>2009-06-07</updated>
   <id></id>
   <content type="html"><p><a href="http://wxruby.rubyforge.org/wiki/wiki.pl">WxRuby</a> is probably the best overall GUI library for Ruby currently available. It is cross-platform, provides native look-and-feel and is stable enough for production use. All other GUI libraries, despite their various merits, fall short in at least one of the areas. However, WxRuby does have one major downfall. It is pretty much a straight port of the C API. Writing WxRuby code is largely the same as writing actual WxWidgets C code. It's far from the "Ruby Way".</p>

<p>So how did I mange to get fairly nice Ruby code despite a binding that is essentially a straight port of the underlying C API? I built it from the bottom-up using a lazy coding technique. And I mean "bottom-up" literally --the following code might actually be easier to read if you start from the bottom and work your way up to the top. The trick is to break down one's interface into individual widgets and create an instance method for each using the <code>||=</code> memoization trick.</p>

<p>You can see from the following code I was able to apply this "trick" to everything but toolbar buttons (aka 'tools'). This is because the toolbar itself is needed to create them. So I simply defined attributes for each tool, but actually created the tool buttons in the toolbar's method. Have a look.</p>

<p>  [gist id="182301"]</p>

<p>The thing to notice, if you haven't caught it yet, is how calling <code>#search_toolbar</code> leads to calling <code>#search_sizer</code> which in turn leads to calling <code>#search_panel</code>, and so forth all the way to the top <code>#frame_panel</code>. This code is a striped down version of actual code I am using. I hope it helps others create wxRuby application more easily. As I said in my previous post, I found in mind-numbingly difficult to create WxRuby interfaces until I worked out this approach. WxRuby is still a difficult API to master, but this technique makes the effort more manageable, and therefore more likely to succeed.</p>

<p>For another example of building structures lazily, have a look at <a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/122593">my solution</a> for <a href="http://rubyquiz.com/quiz10.html">Ruby Quiz 10 - Crosswords</a>.</p>
</content>
 </entry>
 
 <entry>
   <title>GUtopIa Revisited</title>
   <link href="2009/03/gutopia.html"/>
   <updated>2009-03-20</updated>
   <id></id>
   <content type="html"><p>Recently I had to buckle down and create and honest to goodness desktop GUI application in Ruby. So once again, after some six years, I set down to weigh my options. It saddens me to say, after all these years, the state of desktop GUI programming with Ruby is still a rather sorry affair. Yes, there have been many improvements --thanks to the hard work of many a good programmer, but the task of creating a Ruby-based GUI application still remains a very non-Ruby-esque ordeal.</p>

<p>My first attempt at it this time was with <a href="http://shoooes.net/">Shoes</a>. Shoes is a new and very nice GUI engine written largely from scratch by the well known WhyTheLuckyStiff. It's a noble effort and some really <a href="http://the-shoebox.org/">neat programs</a> can come from using Shoes. Unfortunately for my needs Shoes proved to be too buggy and immature --at times I saw visual artifacts and there are a very limited number of controls. And worst of all, the fact that it includes it's own Ruby interpretor and manges it's own gems caused it not to work well with some other libraries. For instance, I could not get it to use the latest version of Mechanize.</p>

<p>After examining other choices, such as creating one GUI script per major platform (too much work), or using the old standby FxRuby (never been happy with the lack of native look-and-feel), I decided to try a different course. I was well versed in web application design, so I tried my hand at rigging a web app to act like a desktop app via a locally running server using Ajax calls. The end result certainly looked good and basically worked. But there was a troubling lack of robustness in the interaction between the front-end and back-end. I had to poll the back-end to see what was going on, and the back-end had to spawn threads in order to provide a response to the browser while continuing to work on long-running processes. So it worked, but barely. I'm sure it could be improved, but for a devote POLSer like myself, that meant getting into mucky waters I really didn't feel like I should need to be diving into anyway. Too bad. Web GUI design is quite advanced compared to Desktop GUI. Why no one has tried to map it directly to the desktop before is beyond me (but you can believe me when I tell you, I can't wait to delve into Plam's pre and it's <a href="http://developer.palm.com/webos_book/book1.html">webOS</a> development platform, which apparently does exactly this).</p>

<p>So where did this leave me? Well, I figured I had one last good shot with <a href="http://wxruby.rubyforge.org/wiki/wiki.pl">wxRuby</a>. Ironically I had something to do with the birth of that project. It was those six years ago that I first looked into GUI frameworks for Ruby. Rich Kilmer was talking about his Utopia/Alpha ideas and I was just starting to feel comfortable with writing scripts in Ruby. I decided there needed to be something better, and working off of Rich's idea's for an API I came up the idea of GUtopIa, which would supply a font-end API that anyone could interface to a back-end GUI framework. Sort of a best of all worlds kind of design. A number of people were psyched about the idea, and joined with me to discuss and pursue the project. Unfortunately, I was still wet behind the ears, and the fellow programmers who first entertained working with me didn't care much for my new-boy-brash style. They told me so, and decided on their own course, to create bindings for wxWidgets instead. I wasn't happy about it personally. Having studied wxWidgets some, I knew it would be a long time before anything really useful was to come of that project --if at all. In hindsight, while I still believe GUtopIa is a good idea, I am glad it's didn't proceed back then --I still had a lot to learn about Ruby before I could do something like that as well as I would really like.</p>

<p>So it was time to check out what the wxRuby team had accomplished. My first handful, or so, attempts were miserable failures. WxRuby has some issues. It is tempermental, and so much like the C API I felt like I was actually programming in C. This is not how Ruby programming is supposed to be! I was having real trouble getting anything more then a basic frame and menu to work. Frustrated with the straight coding approach, I decided to see what WYSIWYG form builders were to be had. I knew wxWidgets touted these, so I looked around and found the precisely named wxFormBuilder. This made it fairly easy to design my complex form and best of all it made it clearer to me how wxWidget GUIs are built. Unfortunately the generated markup, called an XRC file, had issues of it's own and wouldn't load properly into Ruby. Once again, I was at a dead end.</p>

<p>Something really needed to be done about this state of affairs. And so I have decided to resurrect the GUtopIa project. I found my old code, looked at it, scrapped it, and started fresh. I'm going to proceed by specifying the front-end API as much as possible, before even considering back-end implementations. With any luck others will see what I'm doing and offer to build a an interface to their favorite framework. So far what I have looks very sweet. Just to wet your whistle, here's a potential example.</p>

<div class="CodeRay">
  <div class="code"><pre>
  layout = <span style="color:#036;font-weight:bold">GUtopIa</span>::<span style="color:#036;font-weight:bold">Layout</span>.new <span style="color:#080;font-weight:bold">do</span>
    [ [ <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">'</span><span style="">Name</span><span style="color:#710">'</span></span>  ], [ entry ] ]
    [ [ <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">'</span><span style="">Phone</span><span style="color:#710">'</span></span> ], [ entry ] ]
    [ [ <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">'</span><span style="">EMail</span><span style="color:#710">'</span></span> ], [ entry ] ]
  <span style="color:#080;font-weight:bold">end</span>
  layout.show

</pre></div>
</div>

<p>Yes, believe it or not, that's a fairly complete GUI layout. In an upcoming post I'll explain how it all works in more detail. But before I get into that, I still need a working desktop GUI application ASAP! I don't have time to develop GUtopIa for this. So now I've tried again at coding wxRuby from hand, but this time using a very Ruby-esque lazy evaluation approach I had experimented with a long time ago in a <a href="http://www.rubyquiz.com/">Ruby Quiz</a> on <a href="http://www.rubyquiz.com/quiz10.html">crossword puzzle drawing</a>. Finally I got the results I wanted with out going cross-eyed looking at the code. Amazing how a well organized approach can make all the difference. I'll demonstrate my design in my next blog post.</p>
</content>
 </entry>
 
 <entry>
   <title>XML+CSS</title>
   <link href="2009/02/xml-css.html"/>
   <updated>2009-02-10</updated>
   <id></id>
   <content type="html"><h1>The Future of Web Design?</h1>

<p>In a <a href="http://tigerops.org/2009/01/mf-vs-xml.html">previous post</a>, I point out that microformats bring an additional layer of useful information to a document, which I dubbed <em>semantic structure</em>. In short, HTML tags provide useful <em>type</em> information about the data they contain. A good example of this has been the insistent push to use <code>div</code>s rather than <code>table</code>s for page layout. The reason is that tables describe a semantic structure, a table of data, and not layout. I for one have found this a frustrating haggle in the design of my pages. Time and time again I have been stymied by unwieldy <code>div</code>s. Tables are much easier to use, despite additional verbosity. But I have stuck to <code>div</code>s because it is "the right thing to do". Thankfully my saving grace will soon be here. The 3rd revision the CSS standard supports a new <code>display</code> style. With it, one can specify that a div is to behave like a table, table row or table cell. Woohoo! Three cheers for tabley divs!!</p>

<p>This display style led me to think about semantic structure again. If we can designate that a <code>div</code> is a <code>table</code> structure via CSS, then why not any structure? And if <code>div</code>s, why not any tag? If we were able to do that, then semantic structure could be specified solely through CSS. And our HTML pages could go from rather simple, repetitive occurrences of <code>div</code> to ... can you guess?... pure XML.</p>

<p>Let's got through it step by step. Here some HTML:</p>

<p>  [gist id=61726]</p>

<p>Now with CSS 3:</p>

<p>  [gist id=61729]</p>

<p>Of course no one would recommend doing this to something that really is a table of data. But bare with me, because now we are coming full circle:</p>

<p>  [gist id=61730]</p>

<p>I think this is a rather remarkable outcome. And you might be surprised to learn that Firefox handles it just fine. What we have achieved is an ultra-clean separation between the data and it's semantic meaning, via XML, and it's semantic structure, via CSS. If this approach were embraced by the XHTML and CSS standards bodies, I would not be surprised to see it revolutionize web design.</p>
</content>
 </entry>
 
 <entry>
   <title>What's &micro;F got on XML?</title>
   <link href="2009/01/mf-vs-xml.html"/>
   <updated>2009-01-24</updated>
   <id></id>
   <content type="html"><p>Decisions, decisions. Therein lies the reason why convention over configuration is so bloody great, precisely because it requires fewer decisions. <a href="http://proutils.rubyforge.org/syckle">Syckle</a>, my humble build tool, outputs log files. Yea, logs are good. But the decision I have to make is, "in what format?"</p>

<p>Now old-school would just put out some asterisk-studded text files with plenty of precise timestamps, maybe some nice long <code>------------------------------</code> lines to divide things up. No doubt these files are easy to access and fairly readable. We like out text files. But hey wait. This is the age of magical markups. At the very least we can coax that log into a Wiki-tongue. For us Rubyists, we have rdoc, markdown and textile's just a few gemy fingertips away. These formats can be even easier to read thanks to structural consistency from log to log. Plus, fire-up a web server and we can get some really nice looking HTML too. That's the beauty of Wiki Wiki markup after all.</p>

<p>Now if beauty were all that matter, then there would be no point in looking further. But like America's continental shelves there is untapped wealth going to waste here. There is data in them there logs! The modern buzzword is <em>semantic</em>. Taking logs to the next level requires us to ensure their semantic value. On that account, XML was created, and long predicted the format of the future. Certainly XML has made great strides, but it is still far from meeting its promise. There is simply too much complexity involved in both marking up the content and in generating nice output.</p>

<p>Then comes along the <em>microformat</em>. The microformat combines the semantic capabilities of XML with the layout capabilities of HTML. Microformats are relatively new and still finding their footing. Indeed, I think a <em>Universal Uniform Microformat Specification</em> is ultimately the necessary outcome. In that vain I make a first rough estimate of what such unifying system might look like, and why, contrary to many arguments otherwise, microformats do in fact bring more to the table than XML.</p>

<p>Where XML provides semantic information within a doubly linked hierarchy (via attributes and body), microformats provide the same plus a set of well defined data structures. Microformats provide semantics through a small set of tag attributes, <em>role</em>, <em>rel</em>, <em>rev</em> and primarily the <em>class</em> attribute. The <em>class</em> attribute alone is enough to make microformats fully equatable to XML. We can easily map the same data set in either format:</p>

<div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#070">&lt;people&gt;</span>
    <span style="color:#070">&lt;person&gt;</span>
      <span style="color:#070">&lt;name&gt;</span>John Jay<span style="color:#070">&lt;/name&gt;</span>
    <span style="color:#070">&lt;/person&gt;</span>
  <span style="color:#070">&lt;/people&gt;</span><span style="color:#070">&lt;/pre&gt;</span>

</pre></div>
</div>

<p>As opposed to...</p>

<div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#070">&lt;div</span> <span style="color:#007">class</span>=<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">people</span><span style="color:#710">&quot;</span></span><span style="color:#070">&gt;</span>
    <span style="color:#070">&lt;div</span> <span style="color:#007">class</span>=<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">person</span><span style="color:#710">&quot;</span></span><span style="color:#070">&gt;</span>
      <span style="color:#070">&lt;span</span> <span style="color:#007">class</span>=<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">name</span><span style="color:#710">&quot;</span></span><span style="color:#070">&gt;</span>John Jay<span style="color:#070">&lt;/span&gt;</span>
    <span style="color:#070">&lt;/div&gt;</span>
  <span style="color:#070">&lt;/div&gt;</span><span style="color:#070">&lt;/pre&gt;</span>

</pre></div>
</div>

<p>Although the microformat is more verbose, the two contian the same original semantic value. But the extra verbosity isn't just a waste of UTF bytecodes, it says something. Specifically it gives us a <em>semantic structure</em>. It just so happens that HTML evolved to offer these structures precisely because that is what data presenters require to do their jobs well. And for the same reason, why you are always being beat with the <code>div</code>-stick when you try to take the load road of laying out your pages with tables.</p>

<p>So what semantic structures do micorformats via HTML make available to us? The quick rundown: we have layouts using <em>div</em> and <em>span</em>, lists using <em>ol</em>, <em>ul</em> and <em>li</em>; definition lists using <em>dl</em>, <em>dd</em> and <em>dt</em>; and tables using <em>table</em>, <em>tr</em>, <em>th</em> and <em>td</em>. Those are the obvious structures. There are still other smaller structure's like <em>a</em> for links, and the hefty set of <em>form</em> elements. All these elements provide us a way to say what type of thing our data is or partakes in, not just what the data is.</p>

<p>Clearly, the creators of XML saw the need for something like this and tried to achieve it through XML Namespaces. But namespaces are less effective because they are completely arbitrary, whereas HTML gives us a limited but universal structural language. Seems to me there is a principle to be found here that can be a guide for both the future of HTML and Microformats.</p>
</content>
 </entry>
 
 <entry>
   <title>The YADSL Rule</title>
   <link href="2008/11/yadsl.html"/>
   <updated>2008-11-04</updated>
   <id></id>
   <content type="html"><p>Looks like the Ruby world is a fire with new DSLs for BDD/TDD. There's
<a href="http://rspec.info/">RSpec</a>,
<a href="http://blog.zenspider.com/minitest/">minitest</a>,
<a href="http://test-unit.rubyforge.org/test-unit/">Test::Unit 2.x</a>,
<a href="http://test-spec.rubyforge.org/test-spec/">test-spec</a>,
<a href="http://www.oreillynet.com/ruby/blog/2008/02/assert2.html">Assert 2.0</a>,
<a href="http://expectations.rubyforge.org/">Expectations</a>,
<a href="http://github.com/aslakhellesoy/cucumber/tree/master">Cucumber</a>,
<a href="http://github.com/carlosbrando/remarkable/tree/master">Remarkable</a>,
<a href="http://www.thoughtbot.com/projects/shoulda/">Shoulda</a>
... woulda, coulda ... My word! So many choices. It's fitting that
it's Thanksgiving, what we have here is a <i>cornicopia of framework</i>!!!</p>

<p>Uh... Okay, you'll have to forgive me. I get carried away.</p>

<p>I suppose it all started with that RSpec. Those guys built an incredibly
elaborate nomenclature to help us spell out our code's behaviors in gruesome
detail. But as wonderfully grandiose as it may be, there's just one tiny little
itty-bitty problem... <i>I can't remember it</i>. Oh, sure, I could sit down and
jam it into my already overloaded brain somewhere, but you know what. I ain't
gonna. I already have enough new stuff to learn and I'm not going to bother to
learn another DSL when those I already know work just as well.</p>

<p>So therein lies the serious downside to any new DSL. They require more brain
cells. We're talking the old "learning yet another language" delemma here. I was
thinking about this today, and it strikes me as one of those cool rules we oft
hear about. So I decided to 'writ' one for the occasion.</p>

<blockquote>
  "Don't create a DSL if a native solution would be just as elegant."
</blockquote>


<p>In fact, a good DSL will likely need to be substantially more elegant in order
to fully justify its existence.</p>

<p>I'm calling this the <i>YADSL Rule</i>, for "Yet Another Domain Specific Language".</p>

<p>Now, a quick look around the world of modern programming
(see <a href="http://dzone.com">DZone</a>),
just as quickly makes clear that the YADSL rule is in no short supply of
violations. Indeed, I dare say, that most of programming today is not innovative,
but masquerading around as such via YADSL.</p>

<p>Now I don't want to seem too harsh. There is of course a certain level of
refinement taking place in some areas. And that naturally has to play itself
out. But it's getting a little crazy. Besides test frameworks, web frameworks
and Javscript development frameworks seem to have hit a New Cambrian Explosion.
I don't see how we're supposed to keep up with it.
I can only hope that my little rule might help to cool all
this exuberance down a bit; so we can catch our breaths and take some time
to consider the drenchal downpour of verbage that has befallen us.</p>

<p>Of course, the real problem may be that too many people want to make YANFT
(Yet Another Name For Themselves).</p>

<p>I sware to you. I'm not one of them. But I will be introducing my own Ruby
test framework soon.</p>

<p>No. I'm not kidding.</p>

<p>Don't worry, there's no new DSL to learn. And that's what makes my framework
so very special. I'll keep you posted.</p>
</content>
 </entry>
 
 <entry>
   <title>If and OOPy If</title>
   <link href="2008/09/oop-if.html"/>
   <updated>2008-09-28</updated>
   <id></id>
   <content type="html"><h1>An Ally OOP for If-Conditions</h1>

<p>Ruby takes a unique approach to conditional evaluation: <i>All
objects are equivalent to <code>true</code> except <code>nil</code>
and <code>false</code></i>. No doubt this is a more object-oriented
approach than, say, C's use of <code>0</code> as false, but it's far
from the ideal of OOP all the way down, as any
<a href="http://pozorvlak.livejournal.com/94558.html">Smalltalker</a>
can attest.</p>

<p>Consider the following case. For a while now. I have wanted in my arsonal
of Ruby classes a NullClass defined basically as:</p>

<div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">NullClass</span> &lt; <span style="color:#036;font-weight:bold">NilClass</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">method_missing</span>(*a)
      <span style="color:#038;font-weight:bold">self</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  <span style="color:#036;font-weight:bold">NULL</span> = <span style="color:#036;font-weight:bold">NullClass</span>.new

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">null</span>
    <span style="color:#036;font-weight:bold">NULL</span>
  <span style="color:#080;font-weight:bold">end</span>

</pre></div>
</div>

<p>This object would greatly benefit fluent interfaces. Instead of returning
<code>nil</code>, such intefaces could return <code>null</code>, and no
error would be thrown when invoking any method against it.</p>

<div class="CodeRay">
  <div class="code"><pre>
  obj = null
  obj.it.does.not.matter  <span style="color:#888">#=&gt; null</span>

</pre></div>
</div>

<p>Unfortunately <code>null</code> is not very viable in Ruby
because <code>null</code> still evaluates as <code>true</code>
when used as the expression of a condition. The fact remains,
Ruby is hardcoded to see only the singleton instances of
<code>NilClass<c/code> and <code>FalseClass</code> as false.</p>

<p>I've requested that <code>NullClass</code> be added to core Ruby in
the past (as of yet to no avail) and though I still would like to
see it included, it may be better still to take an altogether
object-oriented approach to conditions --in the spirit of Smalltalk.
This would allow us to freely create "false" objects, like the
<code>NullClass</code>, ourselves.</p>

<p>The adoption of such a capability does not require the odd syntax
used by Smalltalk (<code>ifTrue</code> / <code>ifFalse</code>).
Rather, it can take an approach more akin to Ruby's own <code>case</code>
statements. As with <code>case</code>'s use of <code>#===</code>,
a particular method would be used to evaluate the "truthiness" of
a value. This would apply for all types of conditions:
<code>while</code>, <code>until</code>, etc.</p>

<p>To clarify, let's say this special method is simply called #if, then...</p>

<div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">IfExample</span>
    attr <span style="color:#A60">:if</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(<span style="color:#33B">@if</span>)
      <span style="color:#33B">@if</span> = <span style="color:#080;font-weight:bold">if</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  x = <span style="color:#036;font-weight:bold">IfExample</span>.new(<span style="color:#038;font-weight:bold">false</span>)

  <span style="color:#080;font-weight:bold">if</span> x
    <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">Yes</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">else</span>
    <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">No</span><span style="color:#710">&quot;</span></span>
  <span style="color:#080;font-weight:bold">end</span>

</pre></div>
</div>

<p>The result of this condition would be <code>"No"</code>.</p>

<p>While it may not be an earth shattering adjustment, the additional
flexibility opens up some interesting doors. Not only would classes
like the previously mentioned <code>NullClass</code> become possible,
but conditions themselves become <i>dynamically controllable</i>.</p>

<p>For example, it would allow method probes to fully map method
signatures (the Halting Problem not withstanding). This is not
currently possible in Ruby because a probe cannot pretend to evaluate
to false in order to walk through the false side of a condition.</p>

<p>The idea would require some getting used to --after all a simple
if-statement would no longer do what we Rubyists presently take
for granted. But then, that's the nature of progress, is it not?</p>
</content>
 </entry>
 
 <entry>
   <title>Taskable</title>
   <link href="2008/09/taskable.html"/>
   <updated>2008-09-12</updated>
   <id></id>
   <content type="html"><h1>Taskable</h1>

<p>On more than a few occasions I have taken a stab at writing a general
purpose task system, akin to Rake's, but one that works within the
framework of Ruby class inheritance. I recall my first attempt was
quite an unwieldy beast, and my subsequent attempts were fairly
unwieldy too, but over time they became more concise. Below is the
most concise variation yet, and I was wondering what other thought
of it -- do you see any flaws in the design; does it satisfy all the
criteria of such a system; would you find it useful; etc.</p>

<p>One issue to note about the code, is the use of the *_trigger methods.
I'm not sure that's the best approach. My original approach was
to provide a #run method (you can see it commented out), but this
requires dividing Taskable into two parts, a module for extending and
a module for including, and I try to avoid that design when I can.</p>

<div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#080;font-weight:bold">module</span> <span style="color:#B06;font-weight:bold">Taskable</span>

    <span style="color:#080;font-weight:bold">def</span> <span style="color:#038;font-weight:bold">self</span>.append_features(base)
      base.extend(<span style="color:#038;font-weight:bold">self</span>)
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#888"># Without an argument, returns list of tasks defined for this class.</span>
    <span style="color:#888">#</span>
    <span style="color:#888"># If a task's target name is given, will return the first</span>
    <span style="color:#888"># task matching the name found in the class' inheritance chain.</span>
    <span style="color:#888"># This is important to ensure tasks are inherited in the same manner</span>
    <span style="color:#888"># that methods are.</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">tasks</span>(target=<span style="color:#038;font-weight:bold">nil</span>)
      <span style="color:#080;font-weight:bold">if</span> target
        target = target.to_sym
        anc = ancestors.select{|a| a &lt; <span style="color:#036;font-weight:bold">Taskable</span>} <span style="color:#888">#DSL</span>
        t = <span style="color:#038;font-weight:bold">nil</span>; anc.find{|a| t = a.tasks[target]}
        <span style="color:#080;font-weight:bold">return</span> t
      <span style="color:#080;font-weight:bold">else</span>
        <span style="color:#33B">@tasks</span> ||= {}
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#888"># Set a description to be used by then next defined task in this class.</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">desc</span>(description)
      <span style="color:#33B">@desc</span> = description
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#888"># Define a task.</span>
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">task</span>(target_and_requisite, &amp;function)
      target, requisite, function = *<span style="color:#036;font-weight:bold">Task</span>.parse_arguments(target_and_requisite, &amp;function)
      task = tasks[target.to_sym] ||= (
        tdesc = <span style="color:#33B">@desc</span>
        <span style="color:#33B">@desc</span> = <span style="color:#038;font-weight:bold">nil</span>
        <span style="color:#036;font-weight:bold">Task</span>.new(<span style="color:#038;font-weight:bold">self</span>, target, tdesc)
      )
      task.update(requisite, &amp;function)
      define_method(<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="background:#eee;color:black"><span style="font-weight:bold;color:#777">#{</span>target<span style="font-weight:bold;color:#777">}</span></span><span style="">_trigger</span><span style="color:#710">&quot;</span></span>){ task.run(<span style="color:#038;font-weight:bold">self</span>) }  <span style="color:#888"># or use #run?</span>
      define_method(<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="background:#eee;color:black"><span style="font-weight:bold;color:#777">#{</span>target<span style="font-weight:bold;color:#777">}</span></span><span style="">:task</span><span style="color:#710">&quot;</span></span>, &amp;function) <span style="color:#888"># TODO: in 1.9 use instance_exec instead.</span>
    <span style="color:#080;font-weight:bold">end</span>

    <span style="color:#888"># Run a task.</span>
    <span style="color:#888"># Hmmm... to add this would require another module (to include).</span>
    <span style="color:#888"># But I'm not sure. Maybe trigger method is the better way?</span>
    <span style="color:#888">#</span>
    <span style="color:#888">#def run(target)</span>
    <span style="color:#888">#  #t = self.class.tasks(target)</span>
    <span style="color:#888">#  #t.run(self)</span>
    <span style="color:#888">#  send(&quot;#{target}_trigger&quot;)</span>
    <span style="color:#888">#end</span>

    <span style="color:#888"># = Task Class</span>
    <span style="color:#888">#</span>
    <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Task</span>
      attr <span style="color:#A60">:base</span>
      attr <span style="color:#A60">:target</span>
      attr <span style="color:#A60">:requisite</span>
      attr <span style="color:#A60">:function</span>
      attr <span style="color:#A60">:description</span>

      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>(base, target, description=<span style="color:#038;font-weight:bold">nil</span>, requisite=<span style="color:#038;font-weight:bold">nil</span>, &amp;function)
        <span style="color:#33B">@base</span>        = base
        <span style="color:#33B">@target</span>      = target.to_sym
        <span style="color:#33B">@description</span> = description
        <span style="color:#33B">@requisite</span>   = requisite || []
        <span style="color:#33B">@function</span>    = function
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#888">#</span>
      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">update</span>(requisite, &amp;function)
        <span style="color:#33B">@requisite</span>.concat(requisite).uniq!
        <span style="color:#33B">@function</span> = function <span style="color:#080;font-weight:bold">if</span> function
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#888">#</span>
      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">prerequisite</span>
        base.ancestors.select{ |a| a.is_a?(<span style="color:#036;font-weight:bold">Taskable</span>) }.collect{ |a|
          a.tasks[target].requisite
        }.flatten.uniq
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#888"># invoke target</span>
      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">run</span>(object)
        rd = rule_dag
        rd.each <span style="color:#080;font-weight:bold">do</span> |t|
          object.send(<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="background:#eee;color:black"><span style="font-weight:bold;color:#777">#{</span>t<span style="font-weight:bold;color:#777">}</span></span><span style="">:task</span><span style="color:#710">&quot;</span></span>)
        <span style="color:#080;font-weight:bold">end</span>
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#888">#</span>
      <span style="color:#888">#def call(object)</span>
      <span style="color:#888">#  object.instance_eval(&amp;function)</span>
      <span style="color:#888">#end</span>

      <span style="color:#888"># Collect task dependencies for running.</span>
      <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">rule_dag</span>(cache=[])
        prerequisite.each <span style="color:#080;font-weight:bold">do</span> |r|
          <span style="color:#080;font-weight:bold">next</span> <span style="color:#080;font-weight:bold">if</span> cache.include?(r)
          t = base.tasks[r]
          t.rule_dag(cache)
          <span style="color:#888">#cache &lt;&lt; dep</span>
        <span style="color:#080;font-weight:bold">end</span>
        cache &lt;&lt; target.to_s
        cache
      <span style="color:#080;font-weight:bold">end</span>

      <span style="color:#888">#</span>
      <span style="color:#080;font-weight:bold">def</span> <span style="color:#038;font-weight:bold">self</span>.parse_arguments(name_and_reqs, &amp;action)
        <span style="color:#080;font-weight:bold">if</span> <span style="color:#036;font-weight:bold">Hash</span>===name_and_reqs
          target = name_and_reqs.keys.first.to_s
          reqs = [name_and_reqs.values.first].flatten
        <span style="color:#080;font-weight:bold">else</span>
          target = name_and_reqs.to_s
          reqs = []
        <span style="color:#080;font-weight:bold">end</span>
        <span style="color:#080;font-weight:bold">return</span> target, reqs, action
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

</pre></div>
</div>

<p>Here's a very simple <a href="http://quarry.rubyforge.org">QEDoc</a> demo/spec:</p>

<div class="CodeRay">
  <div class="code"><pre>
  <span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Example</span>
    include <span style="color:#036;font-weight:bold">Taskable</span>

    task <span style="color:#A60">:task_with_no_requisites</span> <span style="color:#080;font-weight:bold">do</span>
      cache &lt;&lt; <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">task_with_no_requisites</span><span style="color:#710">&quot;</span></span>
    <span style="color:#080;font-weight:bold">end</span>

    task <span style="color:#A60">:task_with_one_requisite</span> =&gt; [<span style="color:#A60">:task_with_no_requisites</span>] <span style="color:#080;font-weight:bold">do</span>
      cache &lt;&lt; <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">task_with_one_requisite</span><span style="color:#710">&quot;</span></span>
    <span style="color:#080;font-weight:bold">end</span>
 
    <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">cache</span>
      <span style="color:#33B">@cache</span> ||= []
    <span style="color:#080;font-weight:bold">end</span>
  <span style="color:#080;font-weight:bold">end</span>

  example = <span style="color:#036;font-weight:bold">Example</span>.new
  <span style="color:#888">#example.run :task_with_no_requisites</span>
  example.task_with_no_requisites_trigger
  example.cache.assert == [<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">task_with_no_requisites</span><span style="color:#710">&quot;</span></span>]

  example = <span style="color:#036;font-weight:bold">Example</span>.new
  <span style="color:#888">#example.run :task_with_one_requisite</span>
  example.task_with_one_requisite_trigger
  example.cache.assert == [<span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">task_with_no_requisites</span><span style="color:#710">&quot;</span></span>, <span style="background-color:#fff0f0;color:#D20"><span style="color:#710">&quot;</span><span style="">task_with_one_requisite</span><span style="color:#710">&quot;</span></span>]

</pre></div>
</div>

<p>So, what do you think?</p>
</content>
 </entry>
 

</feed>

