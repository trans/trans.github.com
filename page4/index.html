<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRANSCODE &mdash; Trans Technology and Programming Blog</title>
    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/images/trans-logo.png"/>
    <link href="/feed.xml" rel="alternate" type="application/rss+xml" title="TRANSCODE" />
    <meta name="title" content="TRANSCODE">
    <link rel="canonical" href="http://trans.github.com/page4/">
     
           
    <meta property="og:title" content="TRANSCODE"/>
    <meta property="og:url" content="http://trans.github.com/page4/"/>
    
    
    <meta property="og:site_name" content="TRANSCODE">
</head>
<body>
    
<section class="site-nav">
    <header>
        <nav id="navigation">
            <a class="brand" href="/">
                <img src="/images/trans-logo.png" alt="Inc" height="120px">
            </a>
            <a href="/" class="home">Blog</a>
            <a href="http://github.com/trans">Github</a>
            <a href="/About/">About</a>
        </nav>
        <nav class="tagline">
            <span>Check out all of my open source work</span>
            <a href="http://github.com/trans" class="btn btn-outline">Learn More</a>
        </nav>
    </header>
</section>

<div class="blog-cover" style="background-image:url(/images/blog-cover.jpg);">
    
    <section>
        <div class="container">
            <h1>TRANSCODE</h1>
            <h3>Trans Technology and Programming Blog</h3>
        
            
            <a href="https://twitter.com/transgigamic" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter"></i></a>
            
            
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss"></i>
            </a>
        </div>
    </section>
</div>

<article class="container">

  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2012/02/25/setting-priorities-trumps-warnings/" rel="prefetch">Setting Priorities Trumps Warnings</a></h1>
            <p><h1>Setting Priorities Trumps Warnings</h1>

<p>Today I had to consider how best to handle omission exceptions in the context of test frameworks, and their use case to mark <em>pending tests</em>. In the course of doing so, I realized there are at least two reasonable levels of omission, those there are &quot;ASAP&quot; and those that are &quot;NSM&quot; (Not So Much). Where as other frameworks used their own specially defined classes for these, e.g <code>Pending</code> and <code>Omission</code>, my approach is to re-utilize Ruby&#39;s own <code>NotImplementedError</code>. But then I had to consider how to differentiate between these priorities.</p>

<p>And that&#39;s when the more general notion occurred to me of <strong>Exception Priorities</strong>.</p>

<p>Consider that instead of raising a warning:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="nb">warn</span> <span class="s2">&quot;Don&#39;t do it, mate!&quot;</span>
</code></pre></div>
<p>We could use the the Exception system, setting a low &quot;warning&quot; level priority.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">raise</span> <span class="s2">&quot;Don&#39;t do it, mate!&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
<p>All things being nominal, Ruby would see the priority of this exception is below 0, output the message to <code>$stderr</code> if <code>$VERBOSE=true</code> and then continue on. Hence it is a warning!</p>

<p>With this, <code>#warn</code> could become a simple alias for <code>#raise</code> with a default negative priority.</p>

<p>Now, if that was all there was to it, then there would be little reason to adopt the idea. But there are some really nice advantages to this approach.</p>

<p>With regards to warning messages, we could use the <code>$VERBOSE</code> setting to refine the level of warning we want to be notified about. </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="vg">$VERBOSE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">raise</span> <span class="s2">&quot;More Serious Warning!&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">raise</span> <span class="s2">&quot;Less Serious Warning!&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
<p>In this case we would never see the <code>-2</code> level warning b/c we&#39;ve indicated we don&#39;t want to see those by setting $VERBOSE to higher specific level.</p>

<p>Interestingly enough, we can do the same for actually raising errors! Let&#39;s call the setting <code>$PRIORITY</code> for the sake of discussion.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="vg">$PRIORITY</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">raise</span> <span class="s2">&quot;More Serious Warning!&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">raise</span> <span class="s2">&quot;Less Serious Warning!&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span>
</code></pre></div>
<p>Where as before, the &quot;More Serious Warning&quot; would just have printed a warning message to <code>$stderr</code>, in this case the Exception will actually be raised, b/c we have lowered the threshold at which exceptions are to be raised.</p>

<p>This refinement to Ruby&#39;s Exception system, effectively subsuming the warning system within it, makes for a much more powerful, flexible and thus useful system. Take my original use case, I can set the priority of NotImplementedError to <code>1</code> for ASAPs and <code>0</code> for NSMs, and I can go further allowing testers to set high priorities to be selectable from the command line.</p>

<p>Want another use case? How about a <code>DeprecatedError</code> that has a default priority of <code>-1</code>.</p>

<p>I am certain other will think of other use cases as well. This is one of those pliable features that tend to have far wider applicability then the originating use case.</p>

<p>P.S. I&#39;ve always thought is would make more sense if <code>$VERBOSE</code> were called <code>$WARN</code>.</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2012-25-February" title="February 25, 2012">February 25, 2012</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2012/01/19/rubys-unexceptional-exception-constructor/" rel="prefetch">Rubys Unexceptional Exception Constructor</a></h1>
            <p><p>You would think after all this time Ruby&#39;s Exception class would be a rather robust and clearly comprehensible class.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">  <span class="k">raise</span><span class="p">(</span><span class="n">exception</span> <span class="o">[</span><span class="p">,</span> <span class="n">string</span> <span class="o">[</span><span class="p">,</span> <span class="n">array</span><span class="o">]]</span><span class="p">)</span>
</code></pre></div>
<p>Now lets try something </p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">MyError</span> <span class="o">&lt;</span> <span class="no">Exception</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">()</span>
    <span class="k">super</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="k">raise</span> <span class="no">MyError</span>
<span class="ss">MyError</span><span class="p">:</span> <span class="no">MyError</span>
    <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">12</span>
    <span class="n">from</span> <span class="sr">/home/</span><span class="n">trans</span><span class="o">/.</span><span class="n">rbenv</span><span class="o">/</span><span class="n">versions</span><span class="o">/</span><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="o">-</span><span class="n">rc1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="ss">irb</span><span class="p">:</span><span class="mi">12</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;&#39;</span>
</code></pre></div>
<p>No problem. But now lets try to set the message and the backtrace.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="k">raise</span> <span class="no">MyError</span><span class="p">,</span> <span class="s2">&quot;This is an error!&quot;</span>
<span class="ss">ArgumentError</span><span class="p">:</span> <span class="n">wrong</span> <span class="n">number</span> <span class="n">of</span> <span class="n">arguments</span> <span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">8</span><span class="ss">:in</span> <span class="sb">`initialize&#39;</span>
<span class="sb">    from (irb):13:in `</span><span class="n">exception</span><span class="s1">&#39;</span>
<span class="s1">    from (irb):13:in `raise&#39;</span>
</code></pre></div>
<p>Clearly Ruby expects any Exception&#39;s initialize method to handle the message argument. That&#39;s a rather strict contract for something Ruby is letting us override. But okay, let&#39;s take that as a given. Obviously Ruby is routing the #raise call to the exception&#39;s initializer. So then we should that the third <code>array</code> argument would passed along too. Turns out that&#39;s not the case.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">MyError</span> <span class="o">&lt;</span> <span class="no">Exception</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="nb">p</span> <span class="n">args</span>
    <span class="k">super</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="k">raise</span> <span class="no">MyError</span><span class="p">,</span> <span class="s2">&quot;This is an error!&quot;</span><span class="p">,</span> <span class="nb">caller</span>
<span class="o">[</span><span class="s2">&quot;This is an error!&quot;</span><span class="o">]</span>
<span class="ss">RuntimeError</span><span class="p">:</span> <span class="no">This</span> <span class="n">is</span> <span class="n">an</span> <span class="no">Error</span><span class="o">!</span>
    <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">1</span>
    <span class="n">from</span> <span class="sr">/home/</span><span class="n">trans</span><span class="o">/.</span><span class="n">rbenv</span><span class="o">/</span><span class="n">versions</span><span class="o">/</span><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="o">-</span><span class="n">rc1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="ss">irb</span><span class="p">:</span><span class="mi">12</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;&#39;</span>
</code></pre></div>
<p>Nope. No caller in sight. So where did it go? Turns out Ruby is setting the caller via the error&#39;s <code>#set_backtrace</code> method and doesn&#39;t depend on the initializer to handle it at all. This seems rather odd, since it was keen on letting the initializer handle the message argument, and would blow-up if the class won&#39;t take it.</p>

<p>So the upshot seems to be that we can&#39;t customize an exceptions initializer adn expect <code>#raise</code> to play along.</p>

<p>I actually had another point to make about how things gets even worse. Unfortunately had to take care of other chores and by the time I got back to this blog post (months later) I forgot what these &quot;worse things&quot; were. I think it had something to do with how <code>#message</code> calls <code>#to_s</code> rather then returning the message passed to the initializer. But as said I am not certain now. </p>

<p>My conclusion however is this. I was attempting to make use of an Exception class as something more than a mere container for a string message for the <a href="http://github.com/rubyworks/assay">Assay</a> project. That is when I ran into these oddities which made doing so quite unpleasant. To my dismay I ended up abandoning the approach. I brought some aspects of this up in a <a href="http://bugs.ruby-lang.org/issues/5898">issue report</a>.</p>

<p>For reference, here is the relevant Ruby <a href="https://github.com/ruby/ruby/blob/trunk/eval.c">source code</a>.</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2012-19-January" title="January 19, 2012">January 19, 2012</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2011/10/04/lazy-plus-enumerable-begats-denumerable/" rel="prefetch">Lazy Plus Enumerable Begats Denumerable</a></h1>
            <p><h1>Lazy + Enumerable = Denumerable</h1>

<p>All Rubyists know and love Enumerable. It&#39;s the really the showcase of Ruby&#39;s mixin system. Some Rubyists also know and appreciate <a href="http://moonbase.rydia.net/software/lazy.rb/">lazy.rb</a> MenTaLguY&#39;s excellent lazy evaluation library. But did you know there is library that essentially cross-breeds the ideas of both? It&#39;s called <a href="http://github.com/rubyworks/facets/blob/master/lib/core/facets/denumerable.rb">Denumerable</a> and is included in Ruby Facets (<code>require &#39;facets/denumerable&#39;</code>).</p>

<p>According to Webster&#39;s The term <code>denumerable</code> is just a synonym for <code>enumerable</code>. In Ruby parlance, it takes a more useful distinction of &quot;deferred enumerable&quot;. In other words Denumerable defers actual calculations of a chain of enumerable method calls until the results are actually needed. That&#39;s where the &quot;laziness&quot; comes in. By deferring calculation Ruby is able to optimize the algorithm, in many cases greatly improving performance. It&#39;s even possible to enumerate infinite ranges if the end result itself is finite.</p>

<p>To make it even more convenient there is <a href="http://github.com/rubyworks/facets/blob/master/lib/core/facets/enumerable/defer.rb">Enumerable#defer</a> (<code>require &#39;facets/enumerable/defer&#39;</code>) which delegates an Enumerable object through a Denumerator, just like Ruby&#39;s core Enumerator class.</p>

<p>So, enough talk, right? How about an example.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">1_000_000_000</span><span class="p">)</span><span class="o">.</span><span class="n">defer</span><span class="o">.</span><span class="n">select</span><span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span><span class="o">.</span>
                                 <span class="n">map</span><span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">100</span> <span class="p">}</span><span class="o">.</span>
                                 <span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
    <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">102</span><span class="p">,</span> <span class="mi">104</span><span class="p">,</span> <span class="mi">106</span><span class="p">,</span> <span class="mi">108</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">114</span><span class="p">,</span> <span class="mi">116</span><span class="p">,</span> <span class="mi">118</span><span class="p">,</span> <span class="mi">120</span><span class="o">]</span>
</code></pre></div>
<p>The performance gains of Denumerable cannot be understated. The above example takes 1/10000th of a second to run on my system. I wanted to provide the time it takes to run without <code>defer</code>, but after an hour of waiting and listening to it eat my hard drive for breakfast, I gave up.</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2011-04-October" title="October 04, 2011">October 04, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2011/10/02/indentured-stringitude/" rel="prefetch">Indentured Stringitude</a></h1>
            <p><h1>Indentured Stringitude</h1>

<p>One of the great things about Ruby is the extensive collection of methods
available to the core classes. Of these the String class reigns supreme with
over 100 methods from which to make good use. Among these methods are those we
all use almost every time a string is laid to editor, such as #strip, #+ and #&lt;&lt;.
Others are present that have more specific but important uses, such as #lines, #scan
and #getbyte. There are even a few that can leave one scratching ones head
a bit trying to fathom the usecase, such as #sum.</p>

<p>Yet, despite its wide address, there is a set of methods that have gone
completely overlooked, which is really remarkable when you consider their
purpose, the frequency of their utility and the code savings they provide
when used. These are methods dealing with <em>indentation</em>.</p>

<p>It was many years ago when I first was introduced to these three methods by
Gavin Sinclair: #tab, $tabto and #indent. Their interfaces are:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tab(n)
Aligns each line n spaces.

tabto(n)
Preserves relative tabbing in which the first non-empty line ends up
with n spaces before non-space.

indent(n, c=&#39; &#39;)
Indent left or right by n spaces.
</code></pre></div>
<p>So clearly useful, these were some of the first to make their way in to Ruby
Facets, and they have proven invaluable to me in numerous projects ever since.</p>

<p>Sometime shortly there after, another related method also proved useful at
times, String#margin. It is documented:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">margin(n=0)
Provides a margin controlled string.

  x = %Q{
        |This
        |  is
        |    margin controlled!
        }.margin
</code></pre></div>
<p>This method is useful largely because it prevents a horrible code smell.
How often have you seen some jutting HERE doc that threw all that nicely
indented Ruby code to the wall.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    def help_text
      &lt;&lt;-HERE
Usage: foo bar
-x some option
-y another option
      HERE
    end
</code></pre></div>
<p>This all too common eye blight was the inspiration for the creation of #margin.
In fact, so confident were Peter and I in this approach to remove these ugly
code-squids that we conceived a %-literal to support such a construct would
be an unimpeachable addition to the language itself, allowing the even more
elegant notation:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">x = %L|Usage: foo bar
      |-x some option
      |-y another option
</code></pre></div>
<p>Such a syntax, being built into Ruby proper, would not suffer the computational
overhead of the pure Ruby implementation, or the extraneous brackets.</p>

<p>In all my years of coding Ruby, it seems to me, these are the the clearest
omissions that I have repeatedly found need. And so concluded that they really
should be a part of Ruby proper. And as much as I owe Ruby&#39;s String class for all
the time saving methods it provides, in this case, as often as I&#39;ve had copy and
paste or add a dependency to &#39;facets&#39; just to get these methods, I think the
String class owes me one!</p>

<hr>

<p>title      : String Indenture
author     : trans
categories : [string, ruby]
date       : 2011-10-02
layout     : post</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2011-02-October" title="October 02, 2011">October 02, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2011/09/10/is-it-an-attribute/" rel="prefetch">Is It An Attribute</a></h1>
            <p><h1>Is it an Attribute?</h1>

<p>What exactly is an attribute? From the standpoint of OOP, a Ruby attribute is 
intended to be what is generally referred to as an <i>accessor method</i>.
An accessor method is a means of direct access to an object&#39;s underlying state.
In other words, it is a method for direct access to an instance variable. And
that is exactly what Ruby&#39;s helper class methods, i.e. <code>attr</code>, <code>attr_reader</code>,
<code>attr_writer</code> and <code>attr_accessor</code>, achieve.</p>

<p>However, Ruby&#39;s &quot;accessor methods&quot; are not specially recognized methods, 
(as are <em>properties</em> in Javascript, for example). Rather Ruby simply creates
regular old methods which internally work with the an instance variable. This
fact leads to a bit of puzzlement. If attributes are Ruby&#39;s means for creating 
accessor methods, but attributes are only a short-cut for creating regular
methods, when then is a method an attribute or not an attribute?  For instance:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Foo</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">;</span> <span class="vi">@x</span><span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>Is <code>#x</code> an attribute in this example since it results in the exact same 
class definition as:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Foo</span>
      <span class="kp">attr</span> <span class="ss">:x</span>
    <span class="k">end</span>
</code></pre></div>
<p>It would seem to be, but neither RDoc or YARD will document it as such, even though
both list attributes of a class.</p>

<p>Going a step further, if the later definition <em>is</em> an attribute, which is an accessor
method, what then is:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class Foo
  def x; @x.to_s; end
end
</code></pre></div>
<p>Does the addition of #to_s invalidate #x as an accessor and thus as an attribute?
Is that the case even if @x is <em>supposed</em> to be a string?</p>

<p>More confusing still, since Ruby methods can be rewritten at any time, there is the 
opposite possibility that what appears as an attribute is not actually an accessor
method as all. Experienced Rubyists know that Ruby issues a warning when a method
overwrites another method --even one created via an <code>attr</code> method. But it&#39;s just
a warning and a fairly minor one at that. This can cause some very basic
confusion if an attribute is overwritten by a method.</p>

<p>Ruby&#39;s common documentation tools make this issue very easy to see. Take a class
defined as follows:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class IsItAnAttribute
  # Attribute accessor #foo.
  attr_accessor :foo

  # Attribute reader #foo.
  attr_reader :bar

  # Attribute writer #foo.
  attr_writer :baz

  # Method #foo.
  def foo; @foo + 1; end

  # Method #foo=.
  def foo=(i); @foo = i.to_i - 1; end

  # Method #bar.
  def bar; end

  # Method #bar=(i)
  def bar=(i); @bar = i; end

  # Method #baz.
  def baz; @baz; end
end
</code></pre></div>
<p>In the case of <a href="examples/is-it-an-attribute/rdoc/index.html">RDoc</a>,
it lists <code>bar=</code>, <code>baz</code> and <code>foo=</code> as methods, and <code>bar[R]</code>, <code>baz[W]</code>
and <code>foo[RW]</code> as attributes. The attributes seem reasonable if we simply
take it on faith that attribute declarations are accessors regardless of
what the methods might be doing --it&#39;s the documentors issue. And maybe that
is all we can reasonably expect. But it is odd that #bar is missing from the
method definitions.</p>

<p><a href="examples/is-it-an-attribute/yard/index.html">YARD</a> on the other hand,
also lists <code>bar</code>, <code>baz</code> and <code>foo</code> as attributes, but does not make
it clear if they are readers, writers or both. It also lists <code>bar</code>, <code>baz</code>
and <code>foo</code> as methods, with no indication that writers even exist. YARD has
some attribute related tags for this, but what seems like the proper approach
to improve the documentation appears to do nothing new.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Method #bar.
# @attribute r bar
def bar
end
</code></pre></div>
<p>(And I would add, there is no <code>[view source]</code> link in this case as well.)</p>

<p>So what gives? What really is an attribute? I&#39;m inclined to think we might need
to throw out the whole concept from Ruby, at least as Ruby now stands. Attributes
are nothing more than a meta-programming device to create methods and it&#39;s
impossible to ensure documentation only labels methods that behave as 
accessor methods.</p>

<p>On the other hand, perhaps we should redefine that concept of an attribute,
not as an accessor method, but as any method we want it to be so long as it
accesses an instance variable in some form or fashion (albeit enforcing that
is not strictly possible either). In that case it might be worth adjusting
the attr methods to act as <em>declarations</em> rather then merely meta-methods.
In this way any method could be declared an attribute in the same way that
methods can be declared public, private or protected.</p>

<hr>

<p>title      : Is it an Attribute?
author     : trans
categories : [attributes, oop]
date       : 2011-09-10
layout     : post</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2011-10-September" title="September 10, 2011">September 10, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2011/09/07/ruby-heart-higher-order-functions/" rel="prefetch">Ruby Heart Higher Order Functions</a></h1>
            <p><h1>Ruby Heart High-Order Functions</h1>

<p>Ruby Facets has a class called <a href="http://rubyworks.github.com/rubyfaux/?doc=http://rubyworks.github.com/facets/docs/facets-2.9.3/core.json#api-class-Functor">Functor</a>. In common computer science parlance &quot;functor&quot; simply means an objectified function. Ruby already has more than it&#39;s share of these with Method, Proc and blocks. So what does Functor bring to the table? Its a bit more that just a first-class function. Rather, it is a <i>higher-order function</i>. What it allows us to do is define a function that responds dynamically to a message call. Here is a very basic example to clarify the idea.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="nb">require</span> <span class="s1">&#39;facets/functor&#39;</span>

    <span class="n">f</span> <span class="o">=</span> <span class="no">Functor</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="o">|</span>
      <span class="n">a</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">f</span> <span class="o">+</span> <span class="mi">3</span>   <span class="c1">#=&gt; 6</span>
    <span class="n">f</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">#=&gt; 9</span>
    <span class="n">f</span> <span class="o">**</span> <span class="mi">3</span>  <span class="c1">#=&gt; 27</span>
</code></pre></div>
<p>So how are higher-order functions useful? There are many possibilities. Consider this crazy little core extension that just occurred to me this evening.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="nb">require</span> <span class="s1">&#39;facets/functor&#39;</span>

    <span class="k">class</span> <span class="nc">String</span>
      <span class="k">def</span> <span class="nf">in_case</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
        <span class="no">Functor</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="o">|</span>
          <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="ss">:===</span> 
            <span class="n">a</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
          <span class="k">else</span>
            <span class="kp">nil</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">case</span> <span class="s1">&#39;foo&#39;</span>
    <span class="k">when</span> <span class="s1">&#39;f&#39;</span><span class="o">.</span><span class="n">in_case</span><span class="p">(</span><span class="ss">:start_with?</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">&quot;Hey it starts with an `f`!&quot;</span>
    <span class="k">end</span>
</code></pre></div>
<p>And that&#39;s just off the top of my head. There are many potential uses. In fact, Ruby has a quite popular functor already known as <em>Enumerator</em>. But that is a very specialized implementation. What Functor does is make it easy for us to quickly roll our own generic higher-order functions.</p>

<p>Now you can read plenty of interesting articles about the merits of high-order functions. I&#39;ll even provide you a few links (see below). But what I really want to talk about in this article is the merits of Ruby making higher-order functions an integral part of the core language. Even as the current implementation of Functor stands, I think it would make a good addition to the language. But there is a downside to the implementation in that it must create a new object every time it is used. Using a cache can help, but that raises issues of memory footprint and serialization.</p>

<p>If, on the other hand, Ruby could internalize the concept of a Functor as a fluent method dispatch mechanism, Ruby would be able to remove this overhead. That is to say, if a higher-order function could be defined as a method, albeit a special kind of method, instead of as an object, then the overhead would be removed. Indulge my use of some pseudo-code similar to rescue notation in order to provide you an idea of what our previous example could look like:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">String</span>
      <span class="k">def</span> <span class="nf">in_case</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="ss">:===</span> 
          <span class="n">a</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="kp">nil</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>The exact notation is, of course, not the important thing. The point is that it&#39;s just a special kind of method that Ruby attaches to the class or module, and handles the dispatching mechanics internally without the need for instantiating a new hollow Functor object each time.</p>

<p>I think this would be a very cool feature. One of those things that would set Ruby even further apart from other languages.</p>

<p><strong>UPDATE</strong>: I recently learned that Python handles higher-order functions in an interesting way:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python">    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">g</span>
</code></pre></div>
<p>Ruby doesn&#39;t have first-class methods, so emulating Python&#39;s behaviour here would require a slightly different approach, probably something like:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="n">g</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
      <span class="k">end</span>
      <span class="n">dispatch</span> <span class="n">g</span>
    <span class="k">end</span>
</code></pre></div>
<p>Where <code>dispatch</code> would be a new keyword akin to <code>return</code>. Yet such an approach still suffers from the creation of an spurious object, albeit in this case it is a temporary local lambda that probably can be GC&#39;d pretty quickly. So this is a middle ground possibility. Personally, I still think the previously mentioned special method idea is better. And we want Ruby to better than Python, right? ;)</p>

<p>Links:</p>

<ul>
<li>http://c2.com/cgi/wiki?HigherOrderFunction</li>
<li>http://kbullock.ringworld.org/2007/03/26/higher-order-messaging/</li>
</ul>

<hr>

<p>categories: [functor, higher-order functions]</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2011-07-September" title="September 07, 2011">September 07, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2011/09/05/on-the-meaninglessness-of-class-vs-module/" rel="prefetch">On The Meaninglessness Of Class Vs Module</a></h1>
            <p><h1>Fear Not the Wereclass</h1>

<p><strong>DRAFT</strong></p>

<p>In the spirit of Halloween, lets take the fun example of the Werewolf. Lets say we already have classes for Man and Wolf at our disposal --some very smart programmer already did the hard work for us and developed these definitive representations ;)</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Man</span>
      <span class="k">def</span> <span class="nf">shoot_gun</span>
        <span class="nb">puts</span> <span class="s2">&quot;Bang!&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;After it!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Wolf</span>
      <span class="k">def</span> <span class="nf">howl</span>
        <span class="nb">puts</span> <span class="s2">&quot;Awoooooooo&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;Woosh!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>Now what about our Werewolf? Half-man and half-wolf, what superclass do we use in its case? Most classes have a clear superclass, but some, such as our werewolf, are not as clear-cut. Perhaps we decide that a werewolf in our universe is more like a wolf than a man, so:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Wolf</span>
    <span class="k">end</span>
</code></pre></div>
<p>But we are still left to add Man&#39;s qualities . Ruby gives us no easy way to do this given our original classes. So we are forced to refactor the former Man class into a module.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">module</span> <span class="nn">ManLike</span>
      <span class="k">def</span> <span class="nf">shoot_gun</span>
        <span class="nb">puts</span> <span class="s2">&quot;Bang!&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;After it!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Man</span>
      <span class="kp">include</span> <span class="no">ManLike</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Wolf</span>
      <span class="kp">include</span> <span class="no">ManLike</span>
    <span class="k">end</span>
</code></pre></div>
<p>Well there you go, a bit long winded perhaps, but it does the deed. But hang on. It appears things are a bit worse off than we might have suspected. We thought by using Wolf as the superclass we were saying a warewolf is essentially a wolf, but with some man like qualities. Surely that is what it must mean for a Warewolf to be a subclass of a Wolf. Unfortunately we would be wrong. When we ask a warewolf to <code>give_chase</code>, we discover it is doing it in quite the mainly way, not the wolfly way.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="n">werewolf</span> <span class="o">=</span> <span class="no">Werewolf</span><span class="o">.</span><span class="n">new</span>
    <span class="n">werewold</span><span class="o">.</span><span class="n">give_chase</span>  <span class="c1">#=&gt; &quot;After it!&quot;</span>
</code></pre></div>
<p>Oh dear, that&#39;s not good. The difference lies in the order of lookup. If two methods conflict, guess which one takes precedence? Would you be surprised to know that is not the superclass, but the rather the mixin?</p>

<p>Well, it doesn&#39;t make a great deal of sense, but clearly we have no choice, we must refactor again.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">module</span> <span class="nn">WolfLike</span>
      <span class="k">def</span> <span class="nf">howl</span>
        <span class="nb">puts</span> <span class="s2">&quot;Awoooooooo&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;Woosh!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Wolf</span>
      <span class="kp">include</span> <span class="no">WolfLike</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Man</span>
      <span class="kp">include</span> <span class="no">WolfLike</span>
    <span class="k">end</span>
</code></pre></div>
<p>Well, there we are. Not our ideal conception of things, clearly, but it <i>does what we need it to do</i>... Of course, in the real world the original classes are not necessarily under our control, leading us to the only and unenviable option of re-implementing everything. What a waste.</p>

<p>The fact that Ruby inheritance system in conjunction with it&#39;s mixin system produces a wonky order to method look-up; the fact that we can&#39;t <em>reuse</em> a class as a module when we might have need to do so; and the fact that we are left then only to do things in unseemly manners and duplicating lots of code too, well, to put it&#39;s all a bit frightful. But really, it not just our coding that become strained and more difficult --after all we are programmers, we &quot;work around&quot;. What really is a shame is that it severely limits the utility of Ruby&#39;s inheritance model and contributes in no small part as to why we see so little <em>semantic</em> subclassing in Ruby programs, as opposed to the simplistic base-class designs that we frequently see.</p>

<p>The fact is the division is between class and module is essentially arbitrary.</p>

<p>Consider this little trick:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">  <span class="k">class</span> <span class="nc">Module</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span>
      <span class="n">c</span><span class="o">.</span><span class="n">include</span> <span class="nb">self</span>
      <span class="n">c</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div>
<p>The distinction between a module and a class it Ruby is purely a superficial one that has been hard coded into the language for no utilitarian reason. It is there only as an artifact of the original conceptualization.</p>

<p>Removing the distinction of class vs module has nothing to do with multiple inheritance. Classes still only have a single superclass. Rather it is the principle of ... that is being violated. There is no need for a module to know it&#39;s a module or class it know it&#39;s a class. Both are merely encapsulations. What matters is how they are used.</p>

<p>There is also a wonderful side benefit from this removal. Load order would no longer matter when two different scripts attempt to utilize the same namespace. </p>

<p>Now I can all but guarantee that at some point someone, who very likely hasn&#39;t read this entire post, is going to say &quot;use delegation&quot;. Yes, yes. I am a big fan of delegation myself. But that is not what this article is about. It is about the utilization of Ruby&#39;s inheritance and mixin system. If delegation were always the answer then we might as well flush the whole inheritance and mixin things down the drain and use delegation for everythin. But that&#39;s a different debate. The question here is, if we are going to have inheritance and mixins, then obviously we should make the greatest use of them.</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2011-05-September" title="September 05, 2011">September 05, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2011/07/09/we-dont-need-no-stinking-modules/" rel="prefetch">We Dont Need No Stinking Modules</a></h1>
            <p><h1>We Don&#39;t Need No Stinking Modules</h1>

<p>Among experienced developers you will hear no end of praise for delegation. All things considered, it is the most powerful, flexible and controllable means of incorporating reusable behaviors. Even so, I recollect that I once read, no object-oriented programming language utilized delegation as it&#39;s only means of handling modules.</p>

<p>With the talk of Ruby 2.0 support the concept of Module#mix (essentially a traits system), I can&#39;t help but wonder why bother. In fact, I have a bit of code for you to consider.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">delegate</span><span class="p">)</span>
    <span class="vi">@_delegates</span> <span class="o">&lt;&lt;</span> <span class="n">delegate</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="n">delegate</span> <span class="o">=</span> <span class="vi">@_delegates</span><span class="o">.</span><span class="n">find</span><span class="p">{</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">delegate</span>
      <span class="n">delegate</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>And here we have the basis of a delegate-based reusable component system. Of course, we need to work this at the class level too, if we want move past Prototype-based OOP. That&#39;s not difficult, we just use a class level delegate store, and override #new to insert the delegates on initialization.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">use</span><span class="p">(</span><span class="n">delegate</span><span class="p">)</span>
    <span class="n">delegates</span> <span class="o">&lt;&lt;</span> <span class="n">delegate</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">class_delegates</span>
    <span class="vi">@_delegates</span> <span class="o">||=</span> <span class="o">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">delegate</span><span class="p">)</span>
    <span class="vi">@_delegates</span> <span class="o">&lt;&lt;</span> <span class="n">delegate</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">class_delegates</span> <span class="o">+</span> <span class="vi">@_delegates</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">{</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">delegate</span>
      <span class="n">delegate</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Is there really anything else that we need? Okay sure, it needs to be beefed-up, to do things like &quot;inherit&quot; delegates from superclasses, but as the basis of such a system, it&#39;s square.</p>

<p>Now the caveats.</p>

<ul>
<li><p>It&#39;s not going to be very fast having to &quot;find&quot; the methods like this every time. Granted. But I suspect that an optimized version of this could be implemented in Ruby itself, mitigating most if not all of that.</p></li>
<li><p>The delegate has no access to the delegator&#39;s state. This is a serious issue for mixins like Enumerable. The could be fixed by giving the delegate access to the delegator. Since a delegate can be reused by other objects, this would require duplicating each delegate, or wrapping it in a special container instance, and passing it a reference to the delegator. That would be pretty inefficient though. Better would be a dynamic means of access handled by the Ruby interpreter itself. </p></li>
</ul>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2011-09-July" title="July 09, 2011">July 09, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2010/10/13/ruby-aop-made-simple/" rel="prefetch">Ruby AOP Made Simple</a></h1>
            <p><!-- ---
title: Ruby AOP Made Simple
author: trans
date: 2010-10-13
categories: [aop, cuts, ruby]
layout: post
-->

<h1>Ruby AOP Made Simple</h1>

<h2>Quick Recap</h2>

<p>Aspect Oriented Programming (AOP) is a topic I have spent a fair amount of
time contemplating. I, along with Peter VanBroekhoven, developed
the concept of Cut-based AOP back in 2005-2006. A limited &quot;toy&quot; implementation of
which can be had by installing the <code>cuts</code> gem. The basic idea behind Cut-based
AOP is the <i>transparent subclass</i>, a.k.a. the <em>cut</em>, which is essentially
a subclass that subsumes the role of the class it effects without the programmer
needing any knowledge of it doing do. In this way, the cut serves as the atomic
construct in a purely object-oriented appraoch to AOP. You can read more about it
<a href="http://github.com/rubyworks/cuts/blob/master/RCR.textile">here</a>.</p>

<p>In dicussing this idea on the ruby-talk mailing list it was suggested that
an easier approach would be to forgo the Cut class and simply allow modules
to be &quot;prepended&quot; to the class or module to which they are applied. So for
instance we might write:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">C</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">module</span> <span class="nn">A</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span> <span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">C</span>
      <span class="n">prepend</span> <span class="n">A</span>
    <span class="k">end</span>

    <span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1">#=&gt; &quot;{hello}&quot;</span>
</code></pre></div>
<p>Cut-based AOP is a general OOP design that can be applied to any
object-oriented programming language. But for Ruby, the idea of <code>prepend</code>,
while more limited, does serve much of the same purpose, and the idea is up for 
<a href="">consideration</a> in a future verison of Ruby.</p>

<h2>Another Way</h2>

<p>There is however another way to essentially use prepend-like AOP in Ruby without
extending Ruby in any special way. The trick is simply to design classes
and module to be &quot;AOP-ready&quot;. Here is an example of the above using nothing
more than standard Ruby.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">C</span>
      <span class="k">module</span> <span class="nn">Joinable</span>
        <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;</span> <span class="k">end</span>
      <span class="k">end</span>
      <span class="kp">include</span> <span class="no">Joinable</span>
    <span class="k">end</span>

    <span class="k">module</span> <span class="nn">A</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span> <span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">C</span>
      <span class="kp">include</span> <span class="n">A</span>
    <span class="k">end</span>

    <span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1">#=&gt; &quot;{hello}&quot;</span>
</code></pre></div>
<p>Pretty easy. We have simply encapsulate C&#39;s instance methods in a &quot;Joinable&quot;
module, thus any new inclusions into C itself will actually come <em>before</em>
these methods.</p>

<p>This of course raises the issue of including modules in the normal fashion,
in which case we would need in include them in Joinable itself, e.g.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">C</span>
      <span class="k">module</span> <span class="nn">Joinable</span>
        <span class="kp">include</span> <span class="no">Foo</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>We could facilitate this will a little bit of Ruby magic.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Module</span>
      <span class="n">alias_method</span> <span class="ss">:_include</span><span class="p">,</span> <span class="ss">:include</span>

      <span class="k">def</span> <span class="nf">include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="ss">:Joinable</span><span class="p">)</span>
          <span class="n">core</span> <span class="o">=</span> <span class="nb">const_get</span><span class="p">(</span><span class="ss">:Joinable</span><span class="p">)</span>
          <span class="n">core</span><span class="o">.</span><span class="n">_include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">_include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="ss">:Joinable</span><span class="p">)</span>
          <span class="n">_include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="k">raise</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2"> is not Joinable&quot;</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>This is a very simplistic implementation, but a robust implementation would
be only slightly more complex. Now, as along as we use <code>Joinable</code>,
we can use #prepend.</p>

<!-- ---
title: Ruby AOP Made Simple
author:
  name: trans
date: 2010-10-13
categories: [aop, cuts, ruby]
layout: post
-->
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2010-13-October" title="October 13, 2010">October 13, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h1 class="title"><a href="/2010/06/04/do-the-right-thing-git-porcelain/" rel="prefetch">Do The Right Thing Git Porcelain</a></h1>
            <p><h1>The &quot;Do The Right Thing&quot; Git Porcelain</h1>

<p>Before making any changes to a program, a good developer will make an entry in an issue tracker and then create a separate branch in which to handle the issue. Only then making the necessary changes and finally merge the changes into to the master branch when they are ready. All before finally marking off the issue as complete.</p>

<p>That&#39;s the ideal anyway. It is, unfortunately, too easy to not do these things by skipping a step or never bothering with them at all. Who really wants to waste time with all this? Developer&#39;s just want to get the job done. To remedy this, we might create a &quot;Do The Right Thing&quot; Git porcelain.</p>

<p>Lets say we had a bug to fix. We could simply invoke our DTRT command:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">  <span class="nv">$ </span>dtrt new
</code></pre></div>
<p>An editor (provided by <code>$EDITOR</code>) opens to allow the developer to describe the issue in detail. When saved and exited, it will automatically create a new branch with a name based on the description and check the branch out, ready to go.</p>

<p>Now changes can be made. When complete (which means passing tests, right?) we simply tell DTRT again.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">  <span class="nv">$ </span>dtrt <span class="k">done</span>
</code></pre></div>
<p>And it will merge the current topic branch into master using the issue description we originally gave it. All done. And, hey, we did the right thing!</p>

<p>Such a porcelain alone would be useful, but it gets even better when we start adding hooks into this process.</p>

<p>For instance, a hook can be added such that new issue creation can post an entry directly to an issue tracker such as GitHub Issues. Not only can it post the issue, but when an issue is complete, it can label the ticket with the version it belongs and closes it. Notice the added benefit of this: it creates automatic changelogs! No more writing those tired HISTORY files. In fact, by using DTRT religeously, we can use a tool like <a href="http://rubyworks.github.com/vclog">VCLog</a> to pop out prefect HISTORY files in almost any format.</p>

<p>To encourage proper TDD, a hook on new issue creation could automatically create a test in a preferred format and drop the developer directly into an editor with it. Thus putting TDD in our proverbial laps.</p>

<p>Another hook placed on merging could prevent the completion of the issue branch until all tests pass, thus helping to improve the quality of check-ins.</p>

<p>I have no doubt other&#39;s might come up with a few other helpful hooks as well.</p>

<p>I have not endeavored to implement this, having too many other projects to work on already. But it would make a good project for another inspired soul.</p>
</p>
            <div class="meta">
                Written By <address>trans</a> &mdash;
                <time pubdate datetime="2010-04-June" title="June 04, 2010">June 04, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
    <section class="pagination" style="text-align:center">
      
        
        <a href="/page3" class="btn btn-outline"> Newer</a>
        
      
      
        <a href="/page5" class="btn btn-outline">Older </a>
      
    </section>
</article>


<footer class="site-footer">
    <div class="container">
        &copy; 2014 
        
        <nav>
            <a href="http://transcode.github.com">TRANS</a> &middot;
            <a href="/">Blog</a> &middot;
            <a href="http://github.com/trans">Product</a> &middot; 
            <a href="/About/">About</a>
        </nav>
        
        <nav class="social">
            
            <a href="https://twitter.com/transgigamic" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter black"></i></a>
            
                
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss black"></i>
            </a>
        </nav>
        <p>Incorporated theme by <a href="https://sendtoinc.com">Inc</a></p>
    </div>
</footer>

<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="/assets/main.js"></script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
    (function(d, t) {
        var g = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        g.src = '//hnbutton.appspot.com/static/hn.min.js';
        s.parentNode.insertBefore(g, s);
    }(document, 'script'));
</script>


</body>
</html>
