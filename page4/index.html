<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRANSCODE &mdash; Trans Technology and Programming Blog</title>
    <link href="http://fonts.googleapis.com/css?family=Droid+Sans:400,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/images/trans-logo.png"/>
    <link href="/feed.xml" rel="alternate" type="application/rss+xml" title="TRANSCODE" />
    <meta name="title" content="TRANSCODE">
    <link rel="canonical" href="http://trans.github.com/page4/">
     
           
    <meta property="og:title" content="TRANSCODE"/>
    <meta property="og:url" content="http://trans.github.com/page4/"/>
    
    
    <meta property="og:site_name" content="TRANSCODE">
</head>
<body>
    
<section class="site-nav">
    <header>
        <nav id="navigation">
            <a class="brand" href="/">
                <img src="/images/trans-logo.png" alt="Inc" height="120px">
            </a>
            <a href="/" class="home">Blog</a>
            <a href="/Home">Index</a>
            <a href="http://github.com/trans">Github</a>
            <a href="/About/">About</a>
        </nav>
        <nav class="tagline">
            <span>Check out all of my open source work</span>
            <a href="http://github.com/trans" class="btn btn-outline">Learn More</a>
        </nav>
    </header>
</section>

<div class="blog-cover" style="background-image:url(/images/blog-cover.jpg);">
    
    <section>
        <div class="container">
            <h1>TRANSCODE</h1>
            <h3>Trans Technology and Programming Blog</h3>
        
            
            <a href="https://twitter.com/transgigamic" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter"></i></a>
            
            
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss"></i>
            </a>
        </div>
    </section>
</div>

<article class="container">

  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2011/10/02/indentured-stringitude/" rel="prefetch">Indentured Stringitude</a></h2>
            <p><h1>Indentured Stringitude</h1>

<p>One of the great things about Ruby is the extensive collection of methods
available to the core classes. Of these the String class reigns supreme with
over 100 methods from which to make good use. Among these methods are those we
all use almost every time a string is laid to editor, such as #strip, #+ and #&lt;&lt;.
Others are present that have more specific but important uses, such as #lines, #scan
and #getbyte. There are even a few that can leave one scratching ones head
a bit trying to fathom the usecase, such as #sum.</p>

<p>Yet, despite its wide address, there is a set of methods that have gone
completely overlooked, which is really remarkable when you consider their
purpose, the frequency of their utility and the code savings they provide
when used. These are methods dealing with <em>indentation</em>.</p>

<p>It was many years ago when I first was introduced to these three methods by
Gavin Sinclair: #tab, $tabto and #indent. Their interfaces are:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tab(n)
Aligns each line n spaces.

tabto(n)
Preserves relative tabbing in which the first non-empty line ends up
with n spaces before non-space.

indent(n, c=&#39; &#39;)
Indent left or right by n spaces.
</code></pre></div>
<p>So clearly useful, these were some of the first to make their way in to Ruby
Facets, and they have proven invaluable to me in numerous projects ever since.</p>

<p>Sometime shortly there after, another related method also proved useful at
times, String#margin. It is documented:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">margin(n=0)
Provides a margin controlled string.

  x = %Q{
        |This
        |  is
        |    margin controlled!
        }.margin
</code></pre></div>
<p>This method is useful largely because it prevents a horrible code smell.
How often have you seen some jutting HERE doc that threw all that nicely
indented Ruby code to the wall.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">    def help_text
      &lt;&lt;-HERE
Usage: foo bar
-x some option
-y another option
      HERE
    end
</code></pre></div>
<p>This all too common eye blight was the inspiration for the creation of #margin.
In fact, so confident were Peter and I in this approach to remove these ugly
code-squids that we conceived a %-literal to support such a construct would
be an unimpeachable addition to the language itself, allowing the even more
elegant notation:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">x = %L|Usage: foo bar
      |-x some option
      |-y another option
</code></pre></div>
<p>Such a syntax, being built into Ruby proper, would not suffer the computational
overhead of the pure Ruby implementation, or the extraneous brackets.</p>

<p>In all my years of coding Ruby, it seems to me, these are the the clearest
omissions that I have repeatedly found need. And so concluded that they really
should be a part of Ruby proper. And as much as I owe Ruby&#39;s String class for all
the time saving methods it provides, in this case, as often as I&#39;ve had copy and
paste or add a dependency to &#39;facets&#39; just to get these methods, I think the
String class owes me one!</p>

<hr>

<p>title      : String Indenture
author     : trans
categories : [string, ruby]
date       : 2011-10-02
layout     : post</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2011-02-October" title="October 02, 2011">October 02, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2011/09/10/is-it-an-attribute/" rel="prefetch">Is It An Attribute</a></h2>
            <p><h1>Is it an Attribute?</h1>

<p>What exactly is an attribute? From the standpoint of OOP, a Ruby attribute is 
intended to be what is generally referred to as an <i>accessor method</i>.
An accessor method is a means of direct access to an object&#39;s underlying state.
In other words, it is a method for direct access to an instance variable. And
that is exactly what Ruby&#39;s helper class methods, i.e. <code>attr</code>, <code>attr_reader</code>,
<code>attr_writer</code> and <code>attr_accessor</code>, achieve.</p>

<p>However, Ruby&#39;s &quot;accessor methods&quot; are not specially recognized methods, 
(as are <em>properties</em> in Javascript, for example). Rather Ruby simply creates
regular old methods which internally work with the an instance variable. This
fact leads to a bit of puzzlement. If attributes are Ruby&#39;s means for creating 
accessor methods, but attributes are only a short-cut for creating regular
methods, when then is a method an attribute or not an attribute?  For instance:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Foo</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">;</span> <span class="vi">@x</span><span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>Is <code>#x</code> an attribute in this example since it results in the exact same 
class definition as:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Foo</span>
      <span class="kp">attr</span> <span class="ss">:x</span>
    <span class="k">end</span>
</code></pre></div>
<p>It would seem to be, but neither RDoc or YARD will document it as such, even though
both list attributes of a class.</p>

<p>Going a step further, if the later definition <em>is</em> an attribute, which is an accessor
method, what then is:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class Foo
  def x; @x.to_s; end
end
</code></pre></div>
<p>Does the addition of #to_s invalidate #x as an accessor and thus as an attribute?
Is that the case even if @x is <em>supposed</em> to be a string?</p>

<p>More confusing still, since Ruby methods can be rewritten at any time, there is the 
opposite possibility that what appears as an attribute is not actually an accessor
method as all. Experienced Rubyists know that Ruby issues a warning when a method
overwrites another method --even one created via an <code>attr</code> method. But it&#39;s just
a warning and a fairly minor one at that. This can cause some very basic
confusion if an attribute is overwritten by a method.</p>

<p>Ruby&#39;s common documentation tools make this issue very easy to see. Take a class
defined as follows:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class IsItAnAttribute
  # Attribute accessor #foo.
  attr_accessor :foo

  # Attribute reader #foo.
  attr_reader :bar

  # Attribute writer #foo.
  attr_writer :baz

  # Method #foo.
  def foo; @foo + 1; end

  # Method #foo=.
  def foo=(i); @foo = i.to_i - 1; end

  # Method #bar.
  def bar; end

  # Method #bar=(i)
  def bar=(i); @bar = i; end

  # Method #baz.
  def baz; @baz; end
end
</code></pre></div>
<p>In the case of <a href="examples/is-it-an-attribute/rdoc/index.html">RDoc</a>,
it lists <code>bar=</code>, <code>baz</code> and <code>foo=</code> as methods, and <code>bar[R]</code>, <code>baz[W]</code>
and <code>foo[RW]</code> as attributes. The attributes seem reasonable if we simply
take it on faith that attribute declarations are accessors regardless of
what the methods might be doing --it&#39;s the documentors issue. And maybe that
is all we can reasonably expect. But it is odd that #bar is missing from the
method definitions.</p>

<p><a href="examples/is-it-an-attribute/yard/index.html">YARD</a> on the other hand,
also lists <code>bar</code>, <code>baz</code> and <code>foo</code> as attributes, but does not make
it clear if they are readers, writers or both. It also lists <code>bar</code>, <code>baz</code>
and <code>foo</code> as methods, with no indication that writers even exist. YARD has
some attribute related tags for this, but what seems like the proper approach
to improve the documentation appears to do nothing new.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Method #bar.
# @attribute r bar
def bar
end
</code></pre></div>
<p>(And I would add, there is no <code>[view source]</code> link in this case as well.)</p>

<p>So what gives? What really is an attribute? I&#39;m inclined to think we might need
to throw out the whole concept from Ruby, at least as Ruby now stands. Attributes
are nothing more than a meta-programming device to create methods and it&#39;s
impossible to ensure documentation only labels methods that behave as 
accessor methods.</p>

<p>On the other hand, perhaps we should redefine that concept of an attribute,
not as an accessor method, but as any method we want it to be so long as it
accesses an instance variable in some form or fashion (albeit enforcing that
is not strictly possible either). In that case it might be worth adjusting
the attr methods to act as <em>declarations</em> rather then merely meta-methods.
In this way any method could be declared an attribute in the same way that
methods can be declared public, private or protected.</p>

<hr>

<p>title      : Is it an Attribute?
author     : trans
categories : [attributes, oop]
date       : 2011-09-10
layout     : post</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2011-10-September" title="September 10, 2011">September 10, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2011/09/07/ruby-heart-higher-order-functions/" rel="prefetch">Ruby Heart Higher Order Functions</a></h2>
            <p><h1>Ruby Heart High-Order Functions</h1>

<p>Ruby Facets has a class called <a href="http://rubyworks.github.com/rubyfaux/?doc=http://rubyworks.github.com/facets/docs/facets-2.9.3/core.json#api-class-Functor">Functor</a>. In common computer science parlance &quot;functor&quot; simply means an objectified function. Ruby already has more than it&#39;s share of these with Method, Proc and blocks. So what does Functor bring to the table? Its a bit more that just a first-class function. Rather, it is a <i>higher-order function</i>. What it allows us to do is define a function that responds dynamically to a message call. Here is a very basic example to clarify the idea.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="nb">require</span> <span class="s1">&#39;facets/functor&#39;</span>

    <span class="n">f</span> <span class="o">=</span> <span class="no">Functor</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="o">|</span>
      <span class="n">a</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="n">f</span> <span class="o">+</span> <span class="mi">3</span>   <span class="c1">#=&gt; 6</span>
    <span class="n">f</span> <span class="o">*</span> <span class="mi">3</span>   <span class="c1">#=&gt; 9</span>
    <span class="n">f</span> <span class="o">**</span> <span class="mi">3</span>  <span class="c1">#=&gt; 27</span>
</code></pre></div>
<p>So how are higher-order functions useful? There are many possibilities. Consider this crazy little core extension that just occurred to me this evening.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="nb">require</span> <span class="s1">&#39;facets/functor&#39;</span>

    <span class="k">class</span> <span class="nc">String</span>
      <span class="k">def</span> <span class="nf">in_case</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
        <span class="no">Functor</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="o">|</span>
          <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="ss">:===</span> 
            <span class="n">a</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
          <span class="k">else</span>
            <span class="kp">nil</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">case</span> <span class="s1">&#39;foo&#39;</span>
    <span class="k">when</span> <span class="s1">&#39;f&#39;</span><span class="o">.</span><span class="n">in_case</span><span class="p">(</span><span class="ss">:start_with?</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">&quot;Hey it starts with an `f`!&quot;</span>
    <span class="k">end</span>
</code></pre></div>
<p>And that&#39;s just off the top of my head. There are many potential uses. In fact, Ruby has a quite popular functor already known as <em>Enumerator</em>. But that is a very specialized implementation. What Functor does is make it easy for us to quickly roll our own generic higher-order functions.</p>

<p>Now you can read plenty of interesting articles about the merits of high-order functions. I&#39;ll even provide you a few links (see below). But what I really want to talk about in this article is the merits of Ruby making higher-order functions an integral part of the core language. Even as the current implementation of Functor stands, I think it would make a good addition to the language. But there is a downside to the implementation in that it must create a new object every time it is used. Using a cache can help, but that raises issues of memory footprint and serialization.</p>

<p>If, on the other hand, Ruby could internalize the concept of a Functor as a fluent method dispatch mechanism, Ruby would be able to remove this overhead. That is to say, if a higher-order function could be defined as a method, albeit a special kind of method, instead of as an object, then the overhead would be removed. Indulge my use of some pseudo-code similar to rescue notation in order to provide you an idea of what our previous example could look like:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">String</span>
      <span class="k">def</span> <span class="nf">in_case</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="ss">:===</span> 
          <span class="n">a</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="kp">nil</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>The exact notation is, of course, not the important thing. The point is that it&#39;s just a special kind of method that Ruby attaches to the class or module, and handles the dispatching mechanics internally without the need for instantiating a new hollow Functor object each time.</p>

<p>I think this would be a very cool feature. One of those things that would set Ruby even further apart from other languages.</p>

<p><strong>UPDATE</strong>: I recently learned that Python handles higher-order functions in an interesting way:</p>
<div class="highlight"><pre><code class="python language-python" data-lang="python">    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">g</span>
</code></pre></div>
<p>Ruby doesn&#39;t have first-class methods, so emulating Python&#39;s behaviour here would require a slightly different approach, probably something like:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
      <span class="n">g</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span>
      <span class="k">end</span>
      <span class="n">dispatch</span> <span class="n">g</span>
    <span class="k">end</span>
</code></pre></div>
<p>Where <code>dispatch</code> would be a new keyword akin to <code>return</code>. Yet such an approach still suffers from the creation of an spurious object, albeit in this case it is a temporary local lambda that probably can be GC&#39;d pretty quickly. So this is a middle ground possibility. Personally, I still think the previously mentioned special method idea is better. And we want Ruby to better than Python, right? ;)</p>

<p>Links:</p>

<ul>
<li>http://c2.com/cgi/wiki?HigherOrderFunction</li>
<li>http://kbullock.ringworld.org/2007/03/26/higher-order-messaging/</li>
</ul>

<hr>

<p>categories: [functor, higher-order functions]</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2011-07-September" title="September 07, 2011">September 07, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2011/09/05/on-the-meaninglessness-of-class-vs-module/" rel="prefetch">On The Meaninglessness Of Class Vs Module</a></h2>
            <p><h1>Fear Not the Wereclass</h1>

<p><strong>DRAFT</strong></p>

<p>In the spirit of Halloween, lets take the fun example of the Werewolf. Lets say we already have classes for Man and Wolf at our disposal --some very smart programmer already did the hard work for us and developed these definitive representations ;)</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Man</span>
      <span class="k">def</span> <span class="nf">shoot_gun</span>
        <span class="nb">puts</span> <span class="s2">&quot;Bang!&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;After it!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Wolf</span>
      <span class="k">def</span> <span class="nf">howl</span>
        <span class="nb">puts</span> <span class="s2">&quot;Awoooooooo&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;Woosh!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>Now what about our Werewolf? Half-man and half-wolf, what superclass do we use in its case? Most classes have a clear superclass, but some, such as our werewolf, are not as clear-cut. Perhaps we decide that a werewolf in our universe is more like a wolf than a man, so:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Wolf</span>
    <span class="k">end</span>
</code></pre></div>
<p>But we are still left to add Man&#39;s qualities . Ruby gives us no easy way to do this given our original classes. So we are forced to refactor the former Man class into a module.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">module</span> <span class="nn">ManLike</span>
      <span class="k">def</span> <span class="nf">shoot_gun</span>
        <span class="nb">puts</span> <span class="s2">&quot;Bang!&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;After it!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Man</span>
      <span class="kp">include</span> <span class="no">ManLike</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Wolf</span>
      <span class="kp">include</span> <span class="no">ManLike</span>
    <span class="k">end</span>
</code></pre></div>
<p>Well there you go, a bit long winded perhaps, but it does the deed. But hang on. It appears things are a bit worse off than we might have suspected. We thought by using Wolf as the superclass we were saying a warewolf is essentially a wolf, but with some man like qualities. Surely that is what it must mean for a Warewolf to be a subclass of a Wolf. Unfortunately we would be wrong. When we ask a warewolf to <code>give_chase</code>, we discover it is doing it in quite the mainly way, not the wolfly way.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="n">werewolf</span> <span class="o">=</span> <span class="no">Werewolf</span><span class="o">.</span><span class="n">new</span>
    <span class="n">werewold</span><span class="o">.</span><span class="n">give_chase</span>  <span class="c1">#=&gt; &quot;After it!&quot;</span>
</code></pre></div>
<p>Oh dear, that&#39;s not good. The difference lies in the order of lookup. If two methods conflict, guess which one takes precedence? Would you be surprised to know that is not the superclass, but the rather the mixin?</p>

<p>Well, it doesn&#39;t make a great deal of sense, but clearly we have no choice, we must refactor again.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">module</span> <span class="nn">WolfLike</span>
      <span class="k">def</span> <span class="nf">howl</span>
        <span class="nb">puts</span> <span class="s2">&quot;Awoooooooo&quot;</span>
      <span class="k">end</span>
      <span class="k">def</span> <span class="nf">give_chase</span>
        <span class="nb">puts</span> <span class="s2">&quot;Woosh!&quot;</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Wolf</span>
      <span class="kp">include</span> <span class="no">WolfLike</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">Werewolf</span> <span class="o">&lt;</span> <span class="no">Man</span>
      <span class="kp">include</span> <span class="no">WolfLike</span>
    <span class="k">end</span>
</code></pre></div>
<p>Well, there we are. Not our ideal conception of things, clearly, but it <i>does what we need it to do</i>... Of course, in the real world the original classes are not necessarily under our control, leading us to the only and unenviable option of re-implementing everything. What a waste.</p>

<p>The fact that Ruby inheritance system in conjunction with it&#39;s mixin system produces a wonky order to method look-up; the fact that we can&#39;t <em>reuse</em> a class as a module when we might have need to do so; and the fact that we are left then only to do things in unseemly manners and duplicating lots of code too, well, to put it&#39;s all a bit frightful. But really, it not just our coding that become strained and more difficult --after all we are programmers, we &quot;work around&quot;. What really is a shame is that it severely limits the utility of Ruby&#39;s inheritance model and contributes in no small part as to why we see so little <em>semantic</em> subclassing in Ruby programs, as opposed to the simplistic base-class designs that we frequently see.</p>

<p>The fact is the division is between class and module is essentially arbitrary.</p>

<p>Consider this little trick:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">  <span class="k">class</span> <span class="nc">Module</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="n">c</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span>
      <span class="n">c</span><span class="o">.</span><span class="n">include</span> <span class="nb">self</span>
      <span class="n">c</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div>
<p>The distinction between a module and a class it Ruby is purely a superficial one that has been hard coded into the language for no utilitarian reason. It is there only as an artifact of the original conceptualization.</p>

<p>Removing the distinction of class vs module has nothing to do with multiple inheritance. Classes still only have a single superclass. Rather it is the principle of ... that is being violated. There is no need for a module to know it&#39;s a module or class it know it&#39;s a class. Both are merely encapsulations. What matters is how they are used.</p>

<p>There is also a wonderful side benefit from this removal. Load order would no longer matter when two different scripts attempt to utilize the same namespace. </p>

<p>Now I can all but guarantee that at some point someone, who very likely hasn&#39;t read this entire post, is going to say &quot;use delegation&quot;. Yes, yes. I am a big fan of delegation myself. But that is not what this article is about. It is about the utilization of Ruby&#39;s inheritance and mixin system. If delegation were always the answer then we might as well flush the whole inheritance and mixin things down the drain and use delegation for everythin. But that&#39;s a different debate. The question here is, if we are going to have inheritance and mixins, then obviously we should make the greatest use of them.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2011-05-September" title="September 05, 2011">September 05, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2011/07/09/we-dont-need-no-stinking-modules/" rel="prefetch">We Dont Need No Stinking Modules</a></h2>
            <p><h1>We Don&#39;t Need No Stinking Modules</h1>

<p>Among experienced developers you will hear no end of praise for delegation. All things considered, it is the most powerful, flexible and controllable means of incorporating reusable behaviors. Even so, I recollect that I once read, no object-oriented programming language utilized delegation as it&#39;s only means of handling modules.</p>

<p>With the talk of Ruby 2.0 support the concept of Module#mix (essentially a traits system), I can&#39;t help but wonder why bother. In fact, I have a bit of code for you to consider.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">delegate</span><span class="p">)</span>
    <span class="vi">@_delegates</span> <span class="o">&lt;&lt;</span> <span class="n">delegate</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="n">delegate</span> <span class="o">=</span> <span class="vi">@_delegates</span><span class="o">.</span><span class="n">find</span><span class="p">{</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">delegate</span>
      <span class="n">delegate</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>And here we have the basis of a delegate-based reusable component system. Of course, we need to work this at the class level too, if we want move past Prototype-based OOP. That&#39;s not difficult, we just use a class level delegate store, and override #new to insert the delegates on initialization.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Object</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">use</span><span class="p">(</span><span class="n">delegate</span><span class="p">)</span>
    <span class="n">delegates</span> <span class="o">&lt;&lt;</span> <span class="n">delegate</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">class_delegates</span>
    <span class="vi">@_delegates</span> <span class="o">||=</span> <span class="o">[]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">delegate</span><span class="p">)</span>
    <span class="vi">@_delegates</span> <span class="o">&lt;&lt;</span> <span class="n">delegate</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">class_delegates</span> <span class="o">+</span> <span class="vi">@_delegates</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">{</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span> <span class="n">d</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">if</span> <span class="n">delegate</span>
      <span class="n">delegate</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div>
<p>Is there really anything else that we need? Okay sure, it needs to be beefed-up, to do things like &quot;inherit&quot; delegates from superclasses, but as the basis of such a system, it&#39;s square.</p>

<p>Now the caveats.</p>

<ul>
<li><p>It&#39;s not going to be very fast having to &quot;find&quot; the methods like this every time. Granted. But I suspect that an optimized version of this could be implemented in Ruby itself, mitigating most if not all of that.</p></li>
<li><p>The delegate has no access to the delegator&#39;s state. This is a serious issue for mixins like Enumerable. The could be fixed by giving the delegate access to the delegator. Since a delegate can be reused by other objects, this would require duplicating each delegate, or wrapping it in a special container instance, and passing it a reference to the delegator. That would be pretty inefficient though. Better would be a dynamic means of access handled by the Ruby interpreter itself. </p></li>
</ul>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2011-09-July" title="July 09, 2011">July 09, 2011</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2010/10/13/ruby-aop-made-simple/" rel="prefetch">Ruby AOP Made Simple</a></h2>
            <p><!-- ---
title: Ruby AOP Made Simple
author: trans
date: 2010-10-13
categories: [aop, cuts, ruby]
layout: post
-->

<h1>Ruby AOP Made Simple</h1>

<h2>Quick Recap</h2>

<p>Aspect Oriented Programming (AOP) is a topic I have spent a fair amount of
time contemplating. I, along with Peter VanBroekhoven, developed
the concept of Cut-based AOP back in 2005-2006. A limited &quot;toy&quot; implementation of
which can be had by installing the <code>cuts</code> gem. The basic idea behind Cut-based
AOP is the <i>transparent subclass</i>, a.k.a. the <em>cut</em>, which is essentially
a subclass that subsumes the role of the class it effects without the programmer
needing any knowledge of it doing do. In this way, the cut serves as the atomic
construct in a purely object-oriented appraoch to AOP. You can read more about it
<a href="http://github.com/rubyworks/cuts/blob/master/RCR.textile">here</a>.</p>

<p>In dicussing this idea on the ruby-talk mailing list it was suggested that
an easier approach would be to forgo the Cut class and simply allow modules
to be &quot;prepended&quot; to the class or module to which they are applied. So for
instance we might write:</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">C</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">module</span> <span class="nn">A</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span> <span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">C</span>
      <span class="n">prepend</span> <span class="n">A</span>
    <span class="k">end</span>

    <span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1">#=&gt; &quot;{hello}&quot;</span>
</code></pre></div>
<p>Cut-based AOP is a general OOP design that can be applied to any
object-oriented programming language. But for Ruby, the idea of <code>prepend</code>,
while more limited, does serve much of the same purpose, and the idea is up for 
<a href="">consideration</a> in a future verison of Ruby.</p>

<h2>Another Way</h2>

<p>There is however another way to essentially use prepend-like AOP in Ruby without
extending Ruby in any special way. The trick is simply to design classes
and module to be &quot;AOP-ready&quot;. Here is an example of the above using nothing
more than standard Ruby.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">C</span>
      <span class="k">module</span> <span class="nn">Joinable</span>
        <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;</span> <span class="k">end</span>
      <span class="k">end</span>
      <span class="kp">include</span> <span class="no">Joinable</span>
    <span class="k">end</span>

    <span class="k">module</span> <span class="nn">A</span>
      <span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="s1">&#39;{&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;}&#39;</span> <span class="p">;</span> <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">class</span> <span class="nc">C</span>
      <span class="kp">include</span> <span class="n">A</span>
    <span class="k">end</span>

    <span class="n">C</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1">#=&gt; &quot;{hello}&quot;</span>
</code></pre></div>
<p>Pretty easy. We have simply encapsulate C&#39;s instance methods in a &quot;Joinable&quot;
module, thus any new inclusions into C itself will actually come <em>before</em>
these methods.</p>

<p>This of course raises the issue of including modules in the normal fashion,
in which case we would need in include them in Joinable itself, e.g.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">C</span>
      <span class="k">module</span> <span class="nn">Joinable</span>
        <span class="kp">include</span> <span class="no">Foo</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>We could facilitate this will a little bit of Ruby magic.</p>
<div class="highlight"><pre><code class="ruby language-ruby" data-lang="ruby">    <span class="k">class</span> <span class="nc">Module</span>
      <span class="n">alias_method</span> <span class="ss">:_include</span><span class="p">,</span> <span class="ss">:include</span>

      <span class="k">def</span> <span class="nf">include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="ss">:Joinable</span><span class="p">)</span>
          <span class="n">core</span> <span class="o">=</span> <span class="nb">const_get</span><span class="p">(</span><span class="ss">:Joinable</span><span class="p">)</span>
          <span class="n">core</span><span class="o">.</span><span class="n">_include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">_include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">const_defined?</span><span class="p">(</span><span class="ss">:Joinable</span><span class="p">)</span>
          <span class="n">_include</span><span class="p">(</span><span class="o">*</span><span class="n">mods</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="k">raise</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2"> is not Joinable&quot;</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
</code></pre></div>
<p>This is a very simplistic implementation, but a robust implementation would
be only slightly more complex. Now, as along as we use <code>Joinable</code>,
we can use #prepend.</p>

<!-- ---
title: Ruby AOP Made Simple
author:
  name: trans
date: 2010-10-13
categories: [aop, cuts, ruby]
layout: post
-->
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2010-13-October" title="October 13, 2010">October 13, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2010/06/04/do-the-right-thing-git-porcelain/" rel="prefetch">Do The Right Thing Git Porcelain</a></h2>
            <p><h1>The &quot;Do The Right Thing&quot; Git Porcelain</h1>

<p>Before making any changes to a program, a good developer will make an entry in an issue tracker and then create a separate branch in which to handle the issue. Only then making the necessary changes and finally merge the changes into to the master branch when they are ready. All before finally marking off the issue as complete.</p>

<p>That&#39;s the ideal anyway. It is, unfortunately, too easy to not do these things by skipping a step or never bothering with them at all. Who really wants to waste time with all this? Developer&#39;s just want to get the job done. To remedy this, we might create a &quot;Do The Right Thing&quot; Git porcelain.</p>

<p>Lets say we had a bug to fix. We could simply invoke our DTRT command:</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">  <span class="nv">$ </span>dtrt new
</code></pre></div>
<p>An editor (provided by <code>$EDITOR</code>) opens to allow the developer to describe the issue in detail. When saved and exited, it will automatically create a new branch with a name based on the description and check the branch out, ready to go.</p>

<p>Now changes can be made. When complete (which means passing tests, right?) we simply tell DTRT again.</p>
<div class="highlight"><pre><code class="bash language-bash" data-lang="bash">  <span class="nv">$ </span>dtrt <span class="k">done</span>
</code></pre></div>
<p>And it will merge the current topic branch into master using the issue description we originally gave it. All done. And, hey, we did the right thing!</p>

<p>Such a porcelain alone would be useful, but it gets even better when we start adding hooks into this process.</p>

<p>For instance, a hook can be added such that new issue creation can post an entry directly to an issue tracker such as GitHub Issues. Not only can it post the issue, but when an issue is complete, it can label the ticket with the version it belongs and closes it. Notice the added benefit of this: it creates automatic changelogs! No more writing those tired HISTORY files. In fact, by using DTRT religeously, we can use a tool like <a href="http://rubyworks.github.com/vclog">VCLog</a> to pop out prefect HISTORY files in almost any format.</p>

<p>To encourage proper TDD, a hook on new issue creation could automatically create a test in a preferred format and drop the developer directly into an editor with it. Thus putting TDD in our proverbial laps.</p>

<p>Another hook placed on merging could prevent the completion of the issue branch until all tests pass, thus helping to improve the quality of check-ins.</p>

<p>I have no doubt other&#39;s might come up with a few other helpful hooks as well.</p>

<p>I have not endeavored to implement this, having too many other projects to work on already. But it would make a good project for another inspired soul.</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2010-04-June" title="June 04, 2010">June 04, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2010/06/02/xdg-next-generation/" rel="prefetch">Xdg Next Generation</a></h2>
            <p><h1>XDG NG</h1>

<p>I can never stress enough the value of using the XDG directory standard to
developers. This is one of those standards that can only really benefit us
all if enough developers truly care to make a better eco-system.</p>

<p>I have decided to take two approaches to my encouragment. The first is to
improve the current XDG API to the point of triviality. It will be one script,
which others can copy to their project if they prefer it to having another
dependency. And I will make it even easier to use --one point of entry,
and readily obvious semantics.</p>

<p>But more I have decided to go beyond this and crrate a new standard --a derivation to
the XDG standard that takes an well demonstrated Rails practice into account: convention
over configuration. By doing so the standard can be further simplified and thus 
become even more trivial, and hopfully in this manner become widely supported to 
the benefit of us all.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">~/.cache
~/.config
~/.data
</code></pre></div>
<p>Update: I started a project for this. See <a href="https://github.com/tabcomputing/bds">BDS</a>.</p>

<hr>

<p>title      : XDG Next Generation
author     : trans
categories : [xdg, fhs]
date       : 2010-06-02
layout     : post
published  : false</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2010-02-June" title="June 02, 2010">June 02, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2010/05/19/a-second-look-at-bundler/" rel="prefetch">A Second Look At Bundler</a></h2>
            <p><h1>A Second Look at Bundler</h1>

<p>A few days ago I wrote an article on my concerns with Bundler. Since then I&#39;ve received enough feedback to refine my thoughts. My opinion that the Ruby/Rails community is on a &quot;crazy train&quot; with regards to Bundler has everything to do with state of complexity of Rails code these days and it&#39;s infiltration into plain vanilla Ruby projects. Of course, Bundler&#39;s intent is to do just the opposite, but such is the danger of new technologies that we must be cautious of inevitable unexpected consequences. So, taking the feedback into account, here&#39;s a better breakdown of the ups and downs of Bundler as I now see them.</p>

<h2>On the Upside</h2>

<p><b>Bundling</b>: I have been informed that the ability to bundle gems is a useful feature for administrators of systems with limited Internet access. I did not expect this to be common enough to even warrant a tool (just use a tarball). But apparently is common enough. For this use Bundler is understandably useful. It&#39;s ability to resolve dependencies pre-runtime makes it especially good at doing so.</p>

<p><b>Installs</b>: The <code>bundle install</code> feature has similar applications to bundle. It can be used to ease deployment. More specifically, a deployment script can contain a simple invoke &#39;bundle install&#39;, rather then handle the installation of each gem itself. In addition it makes it easier for developers to get up and running quickly, a simple &#39;bundle install&#39; will install everything you need to develop a project. So this feature has it&#39;s clear benefits.</p>

<p><b>Groups:</b> Groups are convenient when selecting certain gems from the list of all requirement, as a means to specialize usage to the end-users needs. Although perhaps a minor benefit, one can see how it can be useful to the developer. As currently implemented Bundler only supports opt-out groups. It might be nice if it also provided for opt-in selections.</p>

<p><b>Locking</b>: The locking feature is probably Bundler&#39;s most significant feature. It allows the developer to nail down their application to the latest gems that best meet all the requirements as given in the Gemfile. </p>

<p><b>Gemfile</b>: Of course, Rubyists are accustomed to nice DSL to &quot;describe&quot; code. The Gemfile makes excellent use of this ability and it is especially nice to have a single clear file to describe all the dependencies of a project.</p>

<h2>On the Downside</h2>

<p><b>Bundling</b>: The downside of bundling comes when developers misuse the feature. Because Bundler does more than just bundle gems for special deployments, there may be a tendency towards using it in this way regardless of the need to do so. For example, yesterday I cloned the <a href="http::/github.com/qrush/gemcutter">Gemcutter</a> repository. The download consumed 22.61 MiB of space. On close inspection I discovered why. The <code>vendor/cache</code> directory contains a copy of every gem on which Gemcutter depends. Consider what this means. In effect, Bundler has undermined the entire purpose of having a package manger!</p>

<p>If Bundler were an application that handled this feature and only this feature, then I think it would be a much better tool. In doing so it would help deter misuse. And the other features could be left to the domain of another library, or even better, RubyGems proper.</p>

<p><b>Installs</b>: The downside of <code>bundle install</code>, is the lack of refinement it grants the end user. An example is the Rails Gemfile which will installs the sqlite3, postgresql and mysql bindings, regardless of what databases the system actually supports. There may also be other subtle conditions that need to be taken into account on installation. To account for these, the temptation will be to add conditions to the Gemfile itself, blurring the lines between it and a Capfile (as an example). But this will in turn effect the developer&#39;s use of the other features. In the end, the inter-complexities this will cause will simply prove too much.</p>

<p><b>Groups</b>: You&#39;ll be happy to know there is nothing intrinsically problematic with groups. Other than the additional complexities they add to the process of designing a Gemfile and the installation thereof, they server their purpose. Sometimes additional complexity is the necessity of capability.</p>

<p><b>Locking</b>: Ironically, Bundler&#39;s most useful feature is probably it&#39;s most problematic. First, in order to achieve this level of functionality, Bundler must download a slew of gems to your system in order to calculate the best fitting requirements. But worse than this, locking brings <code>Bundler.require</code> into play. <code>Bundler.require</code> admits of the same issues as <code>require &#39;rubygems&#39;</code>. It can not be used without limiting an program to the RubyGems package manager. If it is to be used congenially, special conditions will need to be put in place by the developer to ensure a program still runs whether RubyGems is being used or not. Bundler might mitigate this issue by gracefully downgrading if RubyGems is not loaded, but then it must also consider where Bundler&#39;s lock file will be located, say if setup.rb is used for installation.</p>

<p><b>Gemfile</b>: As mentioned, the Gemfile is great to have as a single configuration file to describe dependencies. However, if a project has a gemspec, it still requires dependencies be stated there as well. RubyGems is not able to utilize the Gemfile. Having to state requirements twice violates the DRY principle.</p>

<p>In addition, because the Gemfile is Ruby code it can be full of conditional statements, dynamic code, and all sorts of other spaghetti. All of which make the file unusable to anything but a Ruby script. Worse still, the ability to use conditions has the potential for creating a very unwieldy level of complexity. There is no way, for instance, to query the Gemfile for all requirements that may be need because some of them may be hidden by the current state of an environment variable. The clear remedy to this is to switch to a static file format. Such a format could be utilized by many tools, not just Bundler, including RubyGems itself. This would also help resolve some the issues with bundle install as mentioned above.</p>

<h2>In Conclusion</h2>

<p>Taking the &quot;good, the bad and ugly&quot; into account as we have, the end result would indicate the following potenial points of action:</p>

<ul>
<li>Use a static file format for the Gemfile.</li>
<li>Allow groups to be opt-in as well as opt-out.</li>
<li>Split Bundler into two projects. One strictly for bundling.</li>
<li>Non-bundling features might be integrated into RubyGems proper.</li>
<li>At the very least allow RubyGems to utilize the Gemfile for gem building.</li>
<li>Gracefully downgrade when RubyGems/Bundler is not used.</li>
</ul>

<p>By applying these points, we can tame some of the &quot;crazy train&quot; of complexity. The principles of POLS and KISS are halmarks of a good Rubyist. Let&#39;s not loose that.</p>

<hr>

<p>title      : A Second Look at Bundler
author     : trans
categories : [bundler, rubygems]
date       : 2010-05-19
layout     : post</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2010-19-May" title="May 19, 2010">May 19, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
  
    <section class="index">
        <!-- -->
        <div>
            <h2 class="title"><a href="/2010/05/15/gem-crazy/" rel="prefetch">Gem Crazy</a></h2>
            <p><h1>Gem Crazy</h1>

<p><b>I believe the Ruby community may have finally gone off the rails in it&#39;s collective
crazy train.</b> I have been reading about <a href="http://gembundler.com/">Bundler</a>,
the spiffy new RubyGems manager to be default part of Rails 3.0, and I can&#39;t help but
wonder what track we were even on.</p>

<p>If you don&#39;t know about Bundler yet, you can learn about it
<a href="http://yehudakatz.com/2009/11/03/using-the-new-gem-bundler-today/">here</a>.
I imagine most of you are already aware of it and are now considering how it fits in
with your future development plans. So I want so ask a more fundamental question:
Why does Bundler even exist?</p>

<p>On the surface, we can of course thank Rails. The deployment of web applications
stands apart from the distribution of Ruby packages. Deploying a Rails
application usually means copying an app&#39;s files up to a server, as opposed to
creating a distributable package file (like a gem) and installing that on
the remote machine. Technically the later could be done, but it isn&#39;t, probably
because most web apps are proprietary and do not need wider distribution. Because
Rails developers do not use the normal RubyGems distribution mechanism, which
automatically installs dependencies, they need another way to ensure their apps
dependencies are present, hence the convenience of <code>bundle install</code>.</p>

<p>Bundler achieves this goal in a grand fashion. As its name implies
it does so by giving us the means to download the gems an application is dependent
upon and store them directly within the project itself. These gems get stored in
a project&#39;s <code>vendor/gems/</code> directory. The rationalized benefit being 
that you need never worry about remote services going down (e.g. <code>rubygems.org</code>)
in order to deploy your application, nor ever worry about any potential changes
in a dependent gem. So in brief, one can <em>bundle</em> dependent gems with ones
application.</p>

<p>At first blush it seem like great idea. After all developers use vendoring to 
do something similar while developing an application. But lets consider this
a bit more carefully. The worry of a remote service going down is, honestly, bordering
on paranoia. That&#39;s why mirrors of RubyGems.org exist. If one goes down, the others
remain. The odds of all mirrors going down at the same time are extremely small, and
as you might imagine, such a situation would be corrected very quickly, if it ever did
occur. In fact, if it did happen, there is a fair chance your host will be down too.
So the solution here is not bundling, but redundancy. As for the fear
of &quot;monkey releases&quot; --new versions of a gem that that might break things,
this is somewhat understandable, but redistributing every dependency with each app
is shear overkill. If you are that concerned a gem will break an application you can
always specify exact requirements in the gemspec, and use the <code>gem</code> method to nail the
version down. That, in fact, is the whole point of the <code>gem</code> method. And it is a
perfectly good solution for applications such as a Rails app. Unfortunately is not
a very good solution for general purpose libraries. (As can be read about in any number
of blog posts by searching
<a href="http://www.google.com/search?q=Don%27t+require+%27rubygems%27">Don&#39;t require &#39;rubygems&#39;</a>.)</p>

<p>[Update: I have been informed that the real benefit of bundling is to make
it easier to install an application on machines that has limited Internet access.
In such cases, I can see that Bundler might be handly.]</p>

<p>I should mention that the latest version of Bundler (v0.9) has a light-weight rendition
of bundling, called <em>locking</em>, which doesn&#39;t actually store the gem in the application,
but automatically locks the gems your application uses to specific versions. In other
words, it generates a file which (I assume) will ulitmately be used with the <code>gem</code> method
to nail down the exact versions of gems your application is using at that time of the lock.
This is a much better approach than bloating your application with .gem files, to achieve
the same end, and to Bundler&#39;s credit it makes it easy to keep those <code>gem</code> calls current.
However, it still ties your program to RubyGems, so again it&#39;s not a perfect solution
for reusable libraries.</p>

<p>Another feature Bundler sets out to handle are <em>groups</em>. They are &quot;gem environments&quot;
which can be loaded as a collective, or even omitted during an install. In other words,
they are a way to specify a specific group of gems to the <code>bundle</code> command or in ones
code with <code>Bundler.require</code>. The most common groups you are likely to see are <code>runtime</code>
or <code>production</code>, <code>test</code> and <code>development</code>, patterned after Rails own database
environments. While I will not dismiss out-of-hand the potential of deriving some
utility from this feature, on the whole I suspect it is a YAGNI. Moreover,
it exposes the developer to even more potential deployment errors. I can only 
imagine the failures that will arise because a testing environment
had a gem that the runtime environment forgot to add, but actually needed.</p>

<p>In addition, the use of Bundler promotes the use of <code>Bundler.require</code>. How many
countless hours have been spent reminding people not to put <code>require &#39;rubygems&#39;</code>
in their lib code? Now the issue will be doubly compounded. While we can hope
that Bundler never makes it&#39;s way beyond Rails (or at least end-user apps), I have
already seen it in at least two non-Rails programs.</p>

<p>Lastly, Bundler also provides an ability to depend on git repos, so long as
they track a .gemspec. This feature is a clear address to vendoring, but
via gem dependencies. I won&#39;t even go into all the issues that arise with this
(and seems to somewhat contradict Bundler&#39;s primary purpose --or at least compound its need!).
You can read some of the back and forth on this idea <a href="http://yehudakatz.com/2010/04/02/using-gemspecs-as-intended/">here</a>.
I will say, however, what really strikes me most about this is
how an unproven system takes on such fanfare that it&#39;s proponents now declare we have
all been doing it wrong! A <code>.gemspec</code> should never be generated by some &quot;extraneous
build tool&quot;, but ought to be edited by hand and checked into the scm repository. Wow.</p>

<p>I realized the Bundler is addressing certain needs, primarily of the Rails community.
The problem with Bundler is that it is trying to correct something that is fundamentally
problematic from the start. On two fronts... The first being that RubyGems ties
a packaging system to versioning, so using the <code>gem</code> command will never be a universally
applicable solution to lock down versions. And the second, more significant issue, that RubyGems,
and hence Bundler, cannot avoid <b>version conflicts</b>. RubyGems blows-up when it
encounters a conflict. Bundler only mitigates this issue by selectin suiable version before
runtime. But niether allow different versions to run simultatneously. This is the real heart
of the matter, and it stems from the fundamental lack of version support in Ruby itself.
In my opinion, until that is addressed, all of these fancy solutions are simply trains headed
up the wrong track.</p>

<hr>

<p>title      : Gem Crazy
author     : trans
categories : [ruby, rubygems]
date       : 2010-05-15
layout     : post</p>
</p>
            <div class="meta">
                Written By <address></a> &mdash;
                <time pubdate datetime="2010-15-May" title="May 15, 2010">May 15, 2010</time>
            </div>
        </div>
        <hr>
    </section>
    
    
    <section class="pagination" style="text-align:center">
      
        
        <a href="/page3" class="btn btn-outline">‹ Newer</a>
        
      
      
        <a href="/page5" class="btn btn-outline">Older ›</a>
      
    </section>
</article>


<footer class="site-footer">
    <div class="container">
        &copy; 2014 
        
        <nav>
            <a href="http://transcode.github.com">TRANS</a> &middot;
            <a href="/">Blog</a> &middot;
            <a href="http://github.com/trans">Product</a> &middot; 
            <a href="/About/">About</a>
        </nav>
        
        <nav class="social">
            
            <a href="https://twitter.com/transgigamic" title="Follow on Twitter" target="_blank"><i class="icon icon-twitter black"></i></a>
            
                
            <a href="/feed.xml" title="RSS Feed">
                <i class="icon icon-rss black"></i>
            </a>
        </nav>
        <p>Incorporated theme by <a href="https://sendtoinc.com">Inc</a></p>
    </div>
</footer>

<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="/assets/main.js"></script>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<script>
    (function(d, t) {
        var g = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        g.src = '//hnbutton.appspot.com/static/hn.min.js';
        s.parentNode.insertBefore(g, s);
    }(document, 'script'));
</script>


</body>
</html>
