<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>7R4N5.C0D3 - Mocking Mocks</title>

    <link rel="stylesheet" href="/smeagol/main.css" type="text/css"/> 
    <link rel="stylesheet" href="/smeagol/pygment.css" type="text/css"/>

    <link rel="stylesheet" href="/assets/styles/custom.css?reload=true" type="text/css"/>
    <link rel="stylesheet" href="/assets/styles/social.css?reload=true" type="text/css"/>  

    <!--[if lt IE 9]>
    <script src="/smeagol/html5.js"></script>
    <![endif]-->

    <script type="text/javascript" src="http://code.jquery.com/jquery-1.7.1.min.js"></script>

    <script type="text/javascript" src="/assets/scripts/jquery.easing.js"></script>
    <script type="text/javascript" src="/assets/scripts/jquery.social.share.1.2.min.js"></script>

    <script src="/assets/scripts/main.js"></script>

    <script>
      $(document).ready(function(){
        $('#social-share').dcSocialShare({
          twitterId: 'transgigamic',
          tabText: '<img src="/assets/images/tab_share.png" alt="Share" />',
          buttons: 'twitter,facebook,plusone,stumbleupon,digg,linkedin,pinit'
        });
      });
    </script>

</head>

<body>
	
  <div id="container">
		<div id="header">
			<h1>7R4N5.C0D3</h1>
		</div>

    

		<div id="nav">
      <ul>
<li><a href="/">I BLOG</a></li>
<li><a href="/I-MAKE">I MAKE</a></li>
<li><a href="/I-USE">I USE</a></li>
<li><a href="/I-READ">I READ</a></li>
</ul>

		</div>

		<article>
    	<div id="content">
        <b class="path">&gt; Mocking Mocks</b>
        <h1>Mocking Mocks</h1>

<p>There are a variety of test-double/mocking libraries available for Ruby.
<a href="http://mocha.rubyforge.org/">Mocha</a> is probably the most well known.
<a href="http://rspec.info/">RSpec</a> comes with it's own mock library. I beleive
<a href="http://flexmock.rubyforge.org/">FlexMock</a> is the venerable older gentleman
on the block. And there are plenty of alternatives such as
<a href="http://rubyforge.org/projects/double-ruby">rr</a> and <a href="http://github.com/jm/stump">stump</a>.</p>

<p>I myself have been toying with an implementation, with a goal of maximizing ease
of use and implemetation overhead. In my pursuit I discovered something very
interesting: Ruby doesn't necessairly need a test-double library.</p>

<p>Consider the case of a pure <em>stub</em>. Ruby's Struct class makes pure stubs 
ridiculously easy.</p>

<div class="highlight"><pre>    <span class="n">stub</span> <span class="o">=</span> <span class="no">Struct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:to_s</span><span class="p">)</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">"Hello, World!"</span><span class="p">)</span>
    <span class="n">stub</span><span class="o">.</span><span class="n">to_s</span> <span class="c1">#=&gt; "Hello, World!"</span>
</pre>
</div>


<p>And because Struct.new returns a class, they can be reused, adjusted and 
inherited, like any other Ruby class --pretty sweet.</p>

<p>How about the case of a <em>partial stubs</em>. Since Ruby supports singleton methods,
it is a simple matter of latching a new or overriding method onto an object.</p>

<div class="highlight"><pre>    <span class="n">obj</span> <span class="o">=</span> <span class="s2">"my object"</span>

    <span class="k">def</span> <span class="nc">obj</span><span class="o">.</span><span class="nf">to_s</span>
      <span class="s2">"mocking "</span> <span class="o">+</span> <span class="k">super</span>
    <span class="k">end</span>
</pre>
</div>


<p>I mean, how easy can it get? </p>

<p>Ok. So stubs are easy, but how about <em>mocks</em>? Well, let's first consider what I
call <em>light-weight mocks</em>. These are like mocks in that the set-up conditions
on message invocations, but unlike regular mocks they are triggered during
invocation rather than awaiting a special trigger method (eg. <code>#verify</code>). Again,
these are easy in Ruby. (Note: I am using the <a href="http://proutils.github.com/ae">AE</a>
library for my assertions syntax.)</p>

<div class="highlight"><pre>    <span class="n">obj</span> <span class="o">=</span> <span class="s2">"my object"</span>

    <span class="k">def</span> <span class="nc">obj</span><span class="o">.</span><span class="nf">to_s</span>
      <span class="n">result</span> <span class="o">=</span> <span class="k">super</span>
      <span class="n">result</span><span class="o">.</span><span class="n">assert</span> <span class="o">=~</span> <span class="sr">/^my/</span>
      <span class="n">result</span>
    <span class="k">end</span>

    <span class="n">obj</span><span class="o">.</span><span class="n">to_s</span>
</pre>
</div>


<p>I would argue in most cases light-weight mocks are more than sufficient for most
testing needs. Regular mocks have a tendency to become too enmeshed in implementation,
which creates undo maintenance headaches. Nonetheless, bare with me and we 
we see how to do regular mocks in pure Ruby as well.</p>

<p>Before we get to regular mocks we first need to consider the test <em>spy</em>. Check it out.
We will use one simple helper from Ruby Facets, called Functor.</p>

<div class="highlight"><pre>    <span class="nb">require</span> <span class="s1">'facets/functor'</span>
</pre>
</div>


<p>If you are wondering, the functor is nothing more than a BasicObject that redirects
<code>#missing_method</code> calls to the block you supply it.</p>

<div class="highlight"><pre>    <span class="n">obj</span> <span class="o">=</span> <span class="s2">"my object"</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="o">[]</span>

    <span class="n">spy</span> <span class="o">=</span> <span class="no">Functor</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">|</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="n">rec</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="o">]</span>
      <span class="n">r</span>
    <span class="k">end</span>

    <span class="n">spy</span><span class="o">.</span><span class="n">to_s</span>
</pre>
</div>


<p>All we are doing here is intercepting the calls to <code>obj</code> by delegating through <code>spy</code>.
A record of activity is then being stored in the <code>rec</code> array. With it we can
verify, for instance, that <code>#to_s</code> was called.</p>

<div class="highlight"><pre>    <span class="n">msg</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">find</span><span class="p">{</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="o">|</span> <span class="n">op</span> <span class="o">==</span> <span class="ss">:to_s</span> <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre>
</div>


<p>And that it returned what was expected.</p>

<div class="highlight"><pre>    <span class="n">assert</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">last</span> <span class="o">==</span> <span class="s2">"my object"</span><span class="p">)</span>
</pre>
</div>


<p>Or we can even verify how many times it was called. Lets call it two more times
to be sure.</p>

<div class="highlight"><pre>    <span class="n">spy</span><span class="o">.</span><span class="n">to_s</span>
    <span class="n">spy</span><span class="o">.</span><span class="n">to_s</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">map</span><span class="p">{</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="o">|</span> <span class="n">op</span> <span class="p">}</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="ss">:to_s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</pre>
</div>


<p>A little verbose, but nothing too terribly strenuous to understand.</p>

<p>Alright. So now lets turn to full-fledge <em>mocks</em>. As you might have
suspected, mocks are a trivial derivation of spies. All we need to do
is collect our verifications together on a per-method bases and run
through them subsequent to invocations in question.</p>

<p>First lets reset our target object and spy.</p>

<div class="highlight"><pre>    <span class="n">obj</span> <span class="o">=</span> <span class="s2">"my object"</span>

    <span class="n">rec</span> <span class="o">=</span> <span class="o">[]</span>

    <span class="n">spy</span> <span class="o">=</span> <span class="no">Functor</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="o">|</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
      <span class="n">rec</span> <span class="o">&lt;&lt;</span> <span class="o">[</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="o">]</span>
      <span class="n">r</span>
    <span class="k">end</span>
</pre>
</div>


<p>We will store out verifications in a Hash.</p>

<div class="highlight"><pre>    <span class="n">verify</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span><span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="o">[</span><span class="n">k</span><span class="o">]=[]</span> <span class="p">}</span>
</pre>
</div>


<p>We define our verification procedures.</p>

<div class="highlight"><pre>    <span class="n">verify</span><span class="o">[</span><span class="ss">:to_s</span><span class="o">]</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span> <span class="o">|</span><span class="n">recs</span><span class="o">|</span> 
      <span class="n">recs</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">last</span><span class="o">.</span><span class="n">assert</span> <span class="o">==</span> <span class="s2">"my object"</span>
      <span class="n">recs</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">assert</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">end</span>
</pre>
</div>


<p>Now we can execute the code in question.</p>

<div class="highlight"><pre>    <span class="n">spy</span><span class="o">.</span><span class="n">to_s</span>
</pre>
</div>


<p>And verify by iterating over and calling each verification procedure.</p>

<div class="highlight"><pre>    <span class="n">verify</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">vop</span><span class="p">,</span> <span class="n">tst</span><span class="o">|</span>
      <span class="n">recs</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">select</span><span class="p">{</span> <span class="o">|</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="o">|</span> <span class="n">vop</span> <span class="o">==</span> <span class="n">op</span> <span class="p">}</span>
      <span class="n">tst</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">recs</span><span class="p">)</span>
    <span class="k">end</span>
</pre>
</div>


<p>Granted that by the time we get to mocks, the code has gotten a little
more complex and certainly not as pretty as a dedicated mock library.
Nonetheless, what is remarkable here is that it takes so little to get
so much out of Ruby. With a few helper methods wrapping some of the
above code segments we would hardly know we weren't working with
a full-fledged mocking library.</p>

<p>Moreover as I argued above, one rarely needs to go this far to get
perfectly good test-doubles. Light-weight mocks will cover most
contingencies just as well as their full-fledged brethren without
the worry of taking your tests too far into the realm of implementation
detail.</p>

<hr /><p>title      : Mocking Mocks
author     : trans
date       : 2010-02-14
categories : [tdd, bdd, test, mock]
layout     : post</p>
      </div>
    </article>

    <div id="comments">
      <!-- Commment vis Disqus -->
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /**
         * var disqus_identifier; [Optional but recommended: Define a unique identifier (e.g. post id or slug) for this thread] 
         */
        (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = 'http://transcode.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=transcode">comments powered by Disqus.</a></noscript>
      <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

		<div id="footer">
      <div class="tiger">
      </div>
			<small>Last edited by <b>7rans</b> on December 05, 2011.</small>
			<small style="float:right;">
				This site is a <a href="https://github.com/blog/699-making-github-more-open-git-backed-wikis">GitHub Wiki</a>
				mirror powered by <a href="http://smeagolrb.info">Smeagol</a>.
			</small>
		</div>

  </div>

  <div id="social-share"></div>
</body>
</html>
